<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta name="generator"
    content="HTML Tidy for HTML5 (experimental) for Windows https://github.com/w3c/tidy-html5/tree/c63cc39" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>SQLite Frequently Asked Questions</title>
    <style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #044a64 }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.menubar {
  clear: both;
  border-radius: 8px;
  background: #044a64;
  padding: 0px;
  margin: 0px;
  cell-spacing: 0px;
}    
.toolbar {
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding: 0px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #044a64; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* Things for &amp;quot;fancyformat&amp;quot; documents start here. */
.fancy img+p {font-style:italic}
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#044a64}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: &amp;#39;TODO:&amp;#39; }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of &amp;quot;fancyformat&amp;quot; specific rules. */

</style>
  </head>
  <body>
    <div>
      <!-- container div to satisfy validator -->
      <a href="index.html">
        <img class="logo" src="images/sqlite370_banner.gif" alt="SQLite Logo" border="0" />
      </a>
      <div>
        <!-- IE hack to prevent disappearing logo-->
      </div>
      <div class="tagline">Small. Fast. Reliable.
      <br />Choose any three.</div>
      <table width="100%" class="menubar">
        <tr>
          <td width="100%">
            <div class="toolbar">
            <a href="about.html">关于</a> 
            <a href="sitemap.html">网站地图</a> 
            <a href="docs.html">文档</a> 
            <a href="download.html">下载</a> 
            <a href="copyright.html">许可</a> 
            <a href="news.html">新闻</a> 
            <a href="support.html">支持</a></div>
            <script>
  gMsg = &amp;quot;Search SQLite Docs...&amp;quot;
  function entersearch() {
    var q = document.getElementById(&amp;quot;q&amp;quot;);
    if( q.value == gMsg ) { q.value = &amp;quot;&amp;quot; }
    q.style.color = &amp;quot;black&amp;quot;
    q.style.fontStyle = &amp;quot;normal&amp;quot;
  }
  function leavesearch() {
    var q = document.getElementById(&amp;quot;q&amp;quot;);
    if( q.value == &amp;quot;&amp;quot; ) { 
      q.value = gMsg
      q.style.color = &amp;quot;#044a64&amp;quot;
      q.style.fontStyle = &amp;quot;italic&amp;quot;
    }
  }
  function hideorshow(btn,obj){
    var x = document.getElementById(obj);
    var b = document.getElementById(btn);
    if( x.style.display!=&amp;#39;none&amp;#39; ){
      x.style.display = &amp;#39;none&amp;#39;;
      b.innerHTML=&amp;#39;show&amp;#39;;
    }else{
      x.style.display = &amp;#39;&amp;#39;;
      b.innerHTML=&amp;#39;hide&amp;#39;;
    }
    return false;
  }
</script>
          </td>
          <td>
            <div style="padding:0 1em 0px 0;white-space:nowrap">
              <form name="f" method="get" action="http://www.sqlite.org/search">
              <input id="q" name="q" type="text" onfocus="entersearch()" onblur="leavesearch()"
              style="width:24ex;padding:1px 1ex; border:solid white 1px; font-size:0.9em ; font-style:italic;color:#044a64;"
              value="搜索SQLite文档..." /> 
              <input type="submit" value="Go"
              style="border:solid white 1px;background-color:#044a64;color:white;font-size:0.9em;padding:0 1ex" /></form>
            </div>
          </td>
        </tr>
      </table>
      <div class="startsearch"></div>
      <h2>常见问题
<br />Frequently Asked Questions</h2>
      <ol>
        <li>
          <a href="#q1">如何创建一个AUTOINCREMENT字段。
<br />How do I create an AUTOINCREMENT field.</a>
        </li>
        <li>
          <a href="#q2">SQLite 支持哪些数据类型？
<br />What datatypes does SQLite support?</a>
        </li>
        <li>
          <a href="#q3">SQLite居然允许我将一个string插入到integer类型的数据库字段中！
<br />SQLite lets me insert a string into a database column of type integer!</a>
        </li>
        <li>
          <a href="#q4">为什么 SQLite 不允许在一个表中使用 &#39;0&#39; 和 &#39;0.0&#39; 作为两个不同行的主键？
<br />Why doesn't SQLite allow me to use '0' and '0.0' as the primary
  key on two different rows of the same table?</a>
        </li>
        <li>
          <a href="#q5">多个应用或者一个应用的多个实例是否能同时访问同一个数据库文件？
<br />Can multiple applications or multiple instances of the same
  application access a single database file at the same time?</a>
        </li>
        <li>
          <a href="#q6">SQLite 是线程安全的么？
<br />Is SQLite threadsafe?</a>
        </li>
        <li>
          <a href="#q7">如何列出一个SQLite数据库中的所有表和索引？
<br />How do I list all tables/indices contained in an SQLite database</a>
        </li>
        <li>
          <a href="#q8">SQLite数据库有什么大小限制么？
<br />Are there any known size limits to SQLite databases?</a>
        </li>
        <li>
          <a href="#q9">SQLite中VARCHAR的最大长度是多少？
<br />What is the maximum size of a VARCHAR in SQLite?</a>
        </li>
        <li>
          <a href="#q10">SQLite是否支持BLOB类型？
<br />Does SQLite support a BLOB type?</a>
        </li>
        <li>
          <a href="#q11">在SQLite中如何在一个已有的表上添加或者删除列？
<br />How do I add or delete columns from an existing table in SQLite.</a>
        </li>
        <li>
          <a href="#q12">我删除了大量的数据，但是数据库文件并没有变小，这是bug么？
<br />I deleted a lot of data but the database file did not get any
  smaller.  Is this a bug?</a>
        </li>
        <li>
          <a href="#q13">我能将SQLite用到我的商业软件中，而不交纳版税么？
<br />Can I use SQLite in my commercial product without paying royalties?</a>
        </li>
        <li>
          <a href="#q14">如何使用一个包含了单引号(&#39;)的字符串？
<br />How do I use a string literal that contains an embedded single-quote (')
  character?</a>
        </li>
        <li>
          <a href="#q15">SQLITE_SCHEMA错误是什么意思，为什么会出现？
<br />What is an SQLITE_SCHEMA error, and why am I getting one?</a>
        </li>
        <li>
          <a href="#q16">为什么ROUND(9.95,1) 会返回9.9而不是10.0呢？9.95难道不应该向上取整么？
<br />>Why does ROUND(9.95,1)  return 9.9 instead of 10.0?
  Shouldn't 9.95 round up?</a>
        </li>
        <li>
          <a href="#q17">当我编译SQLite的时候出现了上百个警告，这是因为有问题么？还是表明代码质量较差？
<br />I get some compiler warnings when I compile SQLite.
  Isn't this a problem?  Doesn't it indicate poor code quality?</a>
        </li>
        <li>
          <a href="#q18">无法不区分大小写匹配Unicode字符。
<br />Case-insensitive matching of Unicode characters does not work.</a>
        </li>
        <li>
          <a href="#q19">INSERT操作非常慢——一秒钟只能执行十几条INSERT。
<br />INSERT is really slow - I can only do few dozen INSERTs per second</a>
        </li>
        <li>
          <a href="#q20">我意外从SQLite数据库删除了一些重要信息，我该如何恢复呢？
<br />I accidentally deleted some important information from my SQLite database.
  How can I recover it?</a>
        </li>
        <li>
          <a href="#q21">SQLITE_CORRUPT错误是什么意思？是说数据库异常么？为什么会出现这个错误？
<br />What is an SQLITE_CORRUPT error?  What does it mean for the database
  to be "malformed"? Why am I getting this error?</a>
        </li>
        <li>
          <a href="#q22">SQLite支持外键么？
<br />Does SQLite support foreign keys?</a>
        </li>
        <li>
          <a href="#q23">当我使用SQLITE_OMIT_...编译期选项编译SQLite时出现了编译错误。
<br />I get a compiler error if I use the SQLITE_OMIT_... 
  compile-time options when building SQLite.</a>
        </li>
        <li>
          <a href="#q24">WHERE 子句表达式 
          <tt>column1=&quot;column1&quot;</tt> 无法正确执行。
          会导致表中的所有行全都返回，而不是只有column1值为&quot;column1&quot;的行。
<br />My WHERE clause expression <tt>column1="column1"</tt> does not work.
  It causes every row of the table to be returned, not just the rows
  where column1 has the value "column1".</a>
        </li>
        <li>
          <a href="#q25">SQLite的语法图（又称“铁路”图）是如何生成的？
<br />How are the syntax diagrams (a.k.a. "railroad" diagrams) for
  SQLite generated?</a>
        </li>
        <li>
          <a href="#q26">SQL标准要求在一个UNIQUE约束的列中，当有一个或者多个值为NULL时触发UNIQUE约束，但是SQLite不是这样。这是一个bug么？
<br />The SQL standard requires that a UNIQUE constraint be enforced even if
  one or more of the columns in the constraint are NULL, but SQLite does
  not do this.  Isn't that a bug?</a>
        </li>
        <li>
          <a href="#q27">SQLite的 Export Control Classification Number (ECCN) 是什么？
<br />What is the Export Control Classification Number (ECCN) for SQLite?</a>
        </li>
        <li>
            <a href="#q28">无得查询无法返回我期望的列名，这是个bug么？
<br />My query does not return the column name that I expect.  Is this a bug?</a>
        </li>
      </ol>
      <a name="q1"></a>
      <p>
        <b>(1) 如何创建一个AUTOINCREMENT字段。
<br />(1) How do I create an AUTOINCREMENT field.</b>
      </p>
      <blockquote>
      <p>简单说：当一列声明为
      <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>那么就会自动增长。
<br />Short answer: A column declared <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> will
  autoincrement.</p>
      <p>详细说: 如果你给一列申明为 
      <a href="lang_createtable.html#rowid">INTEGER PRIMARY
      KEY</a>，那么当你插入一个NULL到这个表的这一列中时，NULL将会自动转换为一个比全表中该字段的最大值大1的一个integer类型数值，或者当表是空表时转换成1。（如果最大的integer数值9223372036854775807已经使用了，那么就会随机选择一个没有使用的数值）例如，假如你有一张这样的表：
<br />Longer answer:
  If you declare a column of a table to be <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>, then
  whenever you insert a NULL
  into that column of the table, the NULL is automatically converted
  into an integer which is one greater than the largest value of that
  column over all other rows in the table, or 1 if the table is empty.
  Or, if the largest existing integer key 9223372036854775807 is in use then an
  unused key value is chosen at random.
  For example, suppose you have a table like this:</p>
      <blockquote>
        <pre>
CREATE TABLE t1(
  a INTEGER PRIMARY KEY,
  b INTEGER
);
</pre>
      </blockquote>
      <p>在这个表中，语句
<br />With this table, the statement</p>
      <blockquote>
        <pre>
INSERT INTO t1 VALUES(NULL,123);
</pre>
      </blockquote>
      <p>逻辑上等价于：
<br />is logically equivalent to saying:</p>
      <blockquote>
        <pre>
INSERT INTO t1 VALUES((SELECT max(a) FROM t1)+1,123);
</pre>
      </blockquote>
      <p>函数 
      <a href="c3ref/last_insert_rowid.html">sqlite3_last_insert_rowid()</a> 能返回最近一次insert的integer类型键
<br />There is a function named
  <a href="c3ref/last_insert_rowid.html">sqlite3_last_insert_rowid()</a> which will return the integer key
  for the most recent insert operation.</p>
      <p>注意integer类型的键值是比插入之前表中最大的键还要大的值。新键相对于当前表里所有的键是独一无二的，但是当有键从表中删除时可能会重复出现这个键值。如果想创建一个在表的整个生命期中都是唯一的键，需要为<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>添加<a href="autoinc.html">AUTOINCREMENT</a>关键字。这样当选择键值时会选择比表中曾经出现过的最大值更大的值。如果能取的最大的键曾经在表中存在过，那么这条<a href="lang_insert.html">INSERT</a>就会失败并返回一个<a href="c3ref/c_abort.html">SQLITE_FULL</a>错误码。
<br />Note that the integer key is one greater than the largest
  key that was in the table just prior to the insert.  The new key
  will be unique over all keys currently in the table, but it might
  overlap with keys that have been previously deleted from the
  table.  To create keys that are unique over the lifetime of the
  table, add the <a href="autoinc.html">AUTOINCREMENT</a> keyword to the <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>
  declaration.  Then the key chosen will be one more than the
  largest key that has ever existed in that table.  If the largest
  possible key has previously existed in that table, then the <a href="lang_insert.html">INSERT</a>
  will fail with an <a href="c3ref/c_abort.html">SQLITE_FULL</a> error code.
	  </p></blockquote>
      <a name="q2"></a>
      <p>
        <b>(2) SQLite 支持哪些数据类型？
<br />(2) What datatypes does SQLite support?</b>
      </p>
      <blockquote>SQLite 使用的是 
      <a href="datatype3.html">动态类型</a>。存储内容可以是INTEGER，REAL，TEXT，BLOB或者是NULL
<br />SQLite uses <a href="datatype3.html">dynamic typing</a>.  Content can be stored as INTEGER,
  REAL, TEXT, BLOB, or as NULL.</blockquote>
      <a name="q3"></a>
      <p>
        <b>(3) SQLite居然允许我将一个string插入到integer类型的数据库字段中！
<br />(3) SQLite lets me insert a string into a database column of type integer!</b>
      </p>
      <blockquote>
        <p>这是一个特点而不是bug。SQLite使用的是
        <a href="datatype3.html">动态类型</a>。 所以不实习数据类型的约束。任何数据都能被插入到任何列中。你可以插入一个任意长度的string到integer列中，插入一个浮点数到一个bollean列中，或者插入一个date类型到caracter列中。在CREATE TABLE命令中指定的<a href="datatype3.html">datatype</a>不会限制任何数据插入到列中。每一个列都能存储一个任意长度的string。（有一个例外：一个 <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>类型的列只能插入64-bit signed integer。当你试图将一个非integer的值插入到<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>列中会得到一个错误。）
<br />This is a feature, not a bug.  SQLite uses <a href="datatype3.html">dynamic typing</a>. 
  It does not enforce data type  constraints.  Data of any type can
  (usually) be inserted into any column.  You can put arbitrary length
  strings into integer columns, floating point numbers in boolean columns,
  or dates in character columns.  The <a href="datatype3.html">datatype</a> you assign to a column in the
  CREATE TABLE command does not restrict what data can be put into
  that column.  Every column is able to hold
  an arbitrary length string.  (There is one exception: Columns of
  type <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> may only hold a 64-bit signed integer.
  An error will result
  if you try to put anything other than an integer into an
  <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> column.)</p>
        <p>不过SQLite使用定义的类型作为最佳类型的推荐。所以，例如，如果一个列定义为INTEGER，你试图插入一个string到这一列中，SQLite将会尝试将string转换为一个integer。如果可以转换则插入转换后的integer数值，如果转换失败，则插入string。这个特性被称为
        <a href="datatype3.html#affinity">类亲和性</a>。
<br />But SQLite does use the declared type of a column as a hint
  that you prefer values in that format.  So, for example, if a
  column is of type INTEGER and you try to insert a string into
  that column, SQLite will attempt to convert the string into an
  integer.  If it can, it inserts the integer instead.  If not,
  it inserts the string.  This feature is called <a href="datatype3.html#affinity">type affinity</a>.</p>
      </blockquote>
      <a name="q4"></a>
      <p>
        <b>(4) 为什么 SQLite 不允许在一个表中使用 &#39;0&#39; 和 &#39;0.0&#39; 作为两个不同行的主键？
<br />(4) Why doesn't SQLite allow me to use '0' and '0.0' as the primary
  key on two different rows of the same table?</b>
      </p>
      <blockquote>
        <p>当主键为数值类型时会发生这个问题。如果将主键<a href="datatype3.html">数据类型</a>转为TEXT则可以同时使用。
<br />This problem occurs when your primary key is a numeric type.  Change the
  <a href="datatype3.html">datatype</a> of your primary key to TEXT and it should work.</p>
        <p>每一行都必须有一个唯一的主键。对于一个数值类型的列，SQLite认为<b>&#39;0&#39;</b> 和 
        <b>&#39;0.0&#39;</b> 是同样的值，因为这两个数字在数值上是相同的。（参考前一个问题）因此会导致值不唯一。
<br />Every row must have a unique primary key.  For a column with a
  numeric type, SQLite thinks that <b>'0'</b> and <b>'0.0'</b> are the
  same value because they compare equal to one another numerically.
  (See the previous question.)  Hence the values are not unique.</p>
      </blockquote>
      <a name="q5"></a>
      <p>
        <b>(5) 多个应用或者一个应用的多个实例是否能同时访问同一个数据库文件？
<br />(5) Can multiple applications or multiple instances of the same
  application access a single database file at the same time?</b>
      </p>
      <blockquote>
        <p>多个进程可以在同时打开同一个数据库。多个进程也可以同时进行SELECT操作。但是，任何时候都只能有一个进程可以修改数据库。
<br />Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the
        same time. But only one process can be making changes to the database at any moment in time, however.</p>
        <p>SQLite使用读写锁来控制数据库的访问（在Win95/98/ME下，由于缺乏对读写锁的支持，所以使用了一个概率模拟来替代读写锁）。但是需要小心：如果数据库文件是在NFS文件系统中，那么这个锁机制可能会出现异常。这是因为fcntl()文件锁在许多NFS实现上是损坏的。当需要多个进程同时访问数据库文件时，需要避免将SQLite数据库文件放在NFS中。在Windows中，Microsoft的文档中说明如果没有运行Share.exe守护进程，那么无法在FAT文件系统上使用锁。
一些有丰富Windows经验的人告诉我，网络文件的文件锁有非常多的bug，是无法依赖的。如果他说的是真的，那么在两个以上的Windows机器间共享SQLite数据库可能会导致意想不到的问题。
<br />SQLite uses reader/writer locks to control access to the database. (Under Win95/98/ME which lacks support for
        reader/writer locks, a probabilistic simulation is used instead.) But use caution: this locking mechanism might not work
        correctly if the database file is kept on an NFS filesystem. This is because fcntl() file locking is broken on many NFS
        implementations. You should avoid putting SQLite database files on NFS if multiple processes might try to access the file
        at the same time. On Windows, Microsoft&#39;s documentation says that locking may not work under FAT filesystems if you are
        not running the Share.exe daemon. People who have a lot of experience with Windows tell me that file locking of network
        files is very buggy and is not dependable. If what they say is true, sharing an SQLite database between two or more Windows
        machines might cause unexpected problems.</p>
        <p>我们发现再没有一个其它的<i>嵌入式</i>数据库引擎能支持像SQLite这么多的并发特性。SQLite允许多个进程同时打开一个数据库文件，并且允许多个进程同时读取一个数据库。如果一个进程需要写入时，必须在整个更新过程中锁定整个数据库。但是这通常只需要花费若干毫秒。
        其它进程只需要等待写入完成就可以继续进行自身的事务了。
        其他嵌入式SQL数据库引擎通常一次只允许一个进程连接到数据库上。
<br />We are aware of no other 
        <i>embedded</i> SQL database engine that supports as much concurrency as SQLite. SQLite allows multiple processes to have
        the database file open at once, and for multiple processes to read the database at once. When any process wants to write,
        it must lock the entire database file for the duration of its update. But that normally only takes a few milliseconds.
        Other processes just wait on the writer to finish then continue about their business. Other embedded SQL database engines
        typically only allow a single process to connect to the database at once.</p>
        <p>可是，客户端/服务端数据库引擎（例如PostgreSQL、MySQL或Oracle）通常支持很高级别的并发，并且允许多进程同时写入同一个数据库。
        这在客户端/服务端数据库上是可能的，这是因为它们总是一个控制良好的单独服务进程，可以有效的协调访问。如果你的应用需要大量的并发，那么你应当考虑使用一个客户端/服务端数据库。但是经验来说，大多数的应用所需的并发性远小于其设计中的想象。
<br />However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of
        concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a
        client/server database because there is always a single well-controlled server process available to coordinate access. If
        your application has a need for a lot of concurrency, then you should consider using a client/server database. But
        experience suggests that most applications need much less concurrency than their designers imagine.</p>
        <p>如果SQL试图访问一个被其它进程锁定的文件，那么默认的行为是返回SQLITE_BUSY。你可以使用C代码通过<a href="c3ref/busy_handler.html">sqlite3_busy_handler()</a> 或 
        <a href="c3ref/busy_timeout.html">sqlite3_busy_timeout()</a>API函数来调整行为。
<br />When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You
        can adjust this behavior from C code using the 
        <a href="c3ref/busy_handler.html">sqlite3_busy_handler()</a> or 
        <a href="c3ref/busy_timeout.html">sqlite3_busy_timeout()</a> API functions.</p>
      </blockquote>
      <a name="q6"></a>
      <p>
        <b>(6) SQLite 是线程安全的么？
<br />(6) Is SQLite threadsafe?</b>
      </p>
      <blockquote>
        <p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf">线程是恶魔</a>，应当避开它。
<br />
        <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf">Threads are evil</a>. Avoid them.</p>
        <p>SQLite是线程安全的。我们做出这个让步是因为许多用户都选择了忽略前一段给出的忠告。但是为了达到线程安全，SQLite需要在编译时将SQLITE_THREADSAFE宏指令设置为1。Windows和Linux平台的预编译二进制分发包都是使用这个参数编译的。如果你无法确认你连接入的SQLite库是否是线程安全的，你可以调用<a href="c3ref/threadsafe.html">sqlite3_threadsafe()</a>接口来查询。
<br />SQLite is threadsafe. We make this concession since many users choose to ignore the advice given in the previous
        paragraph. But in order to be thread-safe, SQLite must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1.
        Both the Windows and Linux precompiled binaries in the distribution are compiled this way. If you are unsure if the SQLite
        library you are linking against is compiled to be threadsafe you can call the 
        <a href="c3ref/threadsafe.html">sqlite3_threadsafe()</a> interface to find out.</p>
        <p>在<a href="releaselog/3_3_1.html">SQLite 3.3.1版</a>之前，<b>sqlite3</b>结构体只能在调用<a href="c3ref/open.html">sqlite3_open()</a>创建它的线程中使用。你不能在一个线程中打开一个数据库，然后将句柄传递给另一个线程使用。这是由于一些通用线程实现的局限性（bug？）所致（例如RedHat9）。具体说，在麻烦的系统中一个线程创建的fcntl()锁无法被其它线程移除或修改。自从SQLite为了实现并发控制而严重依赖fcntl()，如果你试图跨线程移动一个数据库连接，那么会引发一个严重的错误。
<br />Prior to 
        <a href="releaselog/3_3_1.html">version 3.3.1</a>, an 
        <b>sqlite3</b> structure could only be used in the same thread that called 
        <a href="c3ref/open.html">sqlite3_open()</a> to create it. You could not open a database in one thread then pass the handle
        off to another thread for it to use. This was due to limitations (bugs?) in many common threading implementations such as
        on RedHat9. Specifically, an fcntl() lock created by one thread cannot be removed or modified by a different thread on the
        troublesome systems. And since SQLite uses fcntl() locks heavily for concurrency control, serious problems arose if you
        start moving database connections across threads.</p>
        <p>跨线程移动数据库连接的限制在<a href="releaselog/3_3_1.html"> 3.3.1 版</a>中得以放宽。在这个版本及后续的版本中，只要这个连接没有持有任何fcntl()锁，那么就可以安全的跨线程移动。你可以放心的假设只要没有执行中的事务并且所有的<a href="c3ref/stmt.html">语句</a>都已经<a href="c3ref/finalize.html">完成</a>，那么就不会持有锁。
<br />The restriction on moving database connections across threads was relaxed somewhat in 
        <a href="releaselog/3_3_1.html">version 3.3.1</a>. With that and subsequent versions, it is safe to move a connection
        handle across threads as long as the connection is not holding any fcntl() locks. You can safely assume that no locks are
        being held if no transaction is pending and all 
        <a href="c3ref/stmt.html">statements</a> have been 
        <a href="c3ref/finalize.html">finalized</a>.</p>
        <p>在Unix下，你不能通过fork()系统调用在子进程中调用一个打开的SQL数据库。这么做会导致问题。
<br />Under Unix, you should not carry an open SQLite database across a fork() system call into the child process. Problems
        will result if you do.</p>
      </blockquote>
      <a name="q7"></a>
      <p>
        <b>(7) 如何列出一个SQLite数据库中的所有表和索引？
<br />(7) How do I list all tables/indices contained in an SQLite database</b>
      </p>
      <blockquote>
        <p>如果你运行了<b>sqlite3</b>命令行访问程序，你可以输入 &quot; <b>.tables</b> &quot; 来获取所有表的列表。你也可以输入&quot; <b>.schema</b>&quot;来查看所有表格和索引的完整数据库结构。这两个命令都可以跟随一个LIKE 模式，这可以限制表的展示。
<br />If you are running the 
        <b>sqlite3</b> command-line access program you can type &quot; 
        <b>.tables</b>&quot; to get a list of all tables. Or you can type &quot; 
        <b>.schema</b>&quot; to see the complete database schema including all tables and indices. Either of these commands can be
        followed by a LIKE pattern that will restrict the tables that are displayed.</p>
        <p>对于在C/C++程序中（或者绑定的Tcl/Ruby/PerlPython脚本中）通过SELECT一个个数的表名&quot; <b>SQLITE_MASTER</b>&quot;来访问表和索引名。每个SQLite数据库都有一个SQLITE_MASTER表，用于定义数据库的结构。SQLITE_MASTER表的结构如下：
<br />From within a C/C++ program (or a script using Tcl/Ruby/Perl/Python bindings) you can get access to table and index
        names by doing a SELECT on a special table named &quot; 
        <b>SQLITE_MASTER</b>&quot;. Every SQLite database has an SQLITE_MASTER table that defines the schema for the database. The
        SQLITE_MASTER table looks like this:</p>
        <blockquote>
          <pre>
CREATE TABLE sqlite_master (
  type TEXT,
  name TEXT,
  tbl_name TEXT,
  rootpage INTEGER,
  sql TEXT
);
</pre>
        </blockquote>
        <p>对于表来说，<b>type</b>字段总是<b>&#39;table&#39;</b>，<b>name</b>字段是表名。所以使用下面的SELECT命令可以获取所有表的列表：
<br />For tables, the 
        <b>type</b> field will always be 
        <b>&#39;table&#39;</b> and the 
        <b>name</b> field will be the name of the table. So to get a list of all tables in the database, use the following SELECT
        command:</p>
        <blockquote>
          <pre>
SELECT name FROM sqlite_master
WHERE type=&#39;table&#39;
ORDER BY name;
</pre>
        </blockquote>
        <p>对于索引来说<b>type</b>字段等于<b>&#39;index&#39;</b>，<b>name</b>字段是索引的名字，<b>tbl_name</b>字段是索引所属的表名。对于表和索引，<b>sql</b>字段是创建表或索引的原始的CREATE TABLE或CREATE INDEX语句文本。对于自动创建的索引（使用PRIMARY KEY或UNIQUE约束实现）<b>sql</b>字段是NULL。
<br />For indices, 
        <b>type</b> is equal to 
        <b>&#39;index&#39;</b>, 
        <b>name</b> is the name of the index and 
        <b>tbl_name</b> is the name of the table to which the index belongs. For both tables and indices, the 
        <b>sql</b> field is the text of the original CREATE TABLE or CREATE INDEX statement that created the table or index. For
        automatically created indices (used to implement the PRIMARY KEY or UNIQUE constraints) the 
        <b>sql</b> field is NULL.</p>
        <p>SQLITE_MASTER表是只读的。你无法使用UPDATE、INSERT或者DELETE来修改表。这个表是通过CREATE TABLE、 CREATE INDEX、 DROP TABLE 和 DROP INDEX命令自动更新的。
<br />The SQLITE_MASTER table is read-only. You cannot change this table using UPDATE, INSERT, or DELETE. The table is
        automatically updated by CREATE TABLE, CREATE INDEX, DROP TABLE, and DROP INDEX commands.</p>
        <p>临时表不会出现在SQLITE_MASTER表中。临时表及其索引和触发器会出现在另一张名为SQLITE_TEMP_MASTER的特殊表中。SQLITE_TEMP_MASTER的功能与SQLITE_MASTER类似，只是SQLITE_TEMP_MASTER表只会对创建了临时表的应用可见。获取包含永久表和临时表的所有表列表可以使用类似下面的命令：
<br />Temporary tables do not appear in the SQLITE_MASTER table. Temporary tables and their indices and triggers occur in
        another special table named SQLITE_TEMP_MASTER. SQLITE_TEMP_MASTER works just like SQLITE_MASTER except that it is only
        visible to the application that created the temporary tables. To get a list of all tables, both permanent and temporary,
        one can use a command similar to the following:</p>
        <blockquote>
          <pre>
SELECT name FROM 
   (SELECT * FROM sqlite_master UNION ALL
    SELECT * FROM sqlite_temp_master)
WHERE type=&#39;table&#39;
ORDER BY name
</pre>
        </blockquote>
      </blockquote>
      <a name="q8"></a>
      <p>
        <b>(8) SQLite数据库有什么大小限制么？
<br />(8) Are there any known size limits to SQLite databases?</b>
      </p>
      <blockquote>
        <p>关于SQLite中限制的详细讨论参见<a href="limits.html">limits.html</a>。
<br />See 
        <a href="limits.html">limits.html</a> for a full discussion of the limits of SQLite.</p>
      </blockquote>
      <a name="q9"></a>
      <p>
        <b>(9) SQLite中VARCHAR的最大长度是多少？
<br />(9) What is the maximum size of a VARCHAR in SQLite?</b>
      </p>
      <blockquote>
        <p>SQLite不会限制VARCHAR的长度。你可以定义个VARCHAR(10)，然后SQLite依然允许你在其中插入500个字符。并且会完整的保存500个字符——永远不会做截断。
<br />SQLite does not enforce the length of a VARCHAR. You can declare a VARCHAR(10) and SQLite will be happy to let you put
        500 characters in it. And it will keep all 500 characters intact - it never truncates.</p>
      </blockquote>
      <a name="q10"></a>
      <p>
        <b>(10) SQLite是否支持BLOB类型？
<br />(10) Does SQLite support a BLOB type?</b>
      </p>
      <blockquote>
        <p>SQLite第三版之后允许在任何列存储BLOB数据，即使列定义为存储其它类型也可以。
<br />SQLite versions 3.0 and later allow you to store BLOB data in any column, even columns that are declared to hold some
        other type.</p>
      </blockquote>
      <a name="q11"></a>
      <p>
        <b>(11) 在SQLite中如何在一个已有的表上添加或者删除列？
<br />(11) How do I add or delete columns from an existing table in SQLite.</b>
      </p>
      <blockquote>
        <p>SQLite只对<a href="lang_altertable.html">ALTER TABLE</a>做了有限的支持，你可以使用它在表的末尾添加一列，或者修改表的名字。如果你想对表结构做其它更复杂的修改，那么你只能重新创建表了。你可以将已有的数据保存到一个临时表中，然后删除旧表，创建新表，最后将数据从临时表中复制回来。
<br />SQLite has limited 
        <a href="lang_altertable.html">ALTER TABLE</a> support that you can use to add a column to the end of a table or to change
        the name of a table. If you want to make more complex changes in the structure of a table, you will have to recreate the
        table. You can save existing data to a temporary table, drop the old table, create the new table, then copy the data back
        in from the temporary table.</p>
        <p>例如，假设你有一个名为&quot;t1&quot;的表，包含的列名为&quot;a&quot;、 &quot;b&quot;、 and
        &quot;c&quot; ，然后你希望从表中删除列&quot;c&quot;。下面的步骤演示了如何做：
<br />For example, suppose you have a table named &quot;t1&quot; with columns names &quot;a&quot;, &quot;b&quot;, and
        &quot;c&quot; and that you want to delete column &quot;c&quot; from this table. The following steps illustrate how this
        could be done:</p>
        <blockquote>
          <pre>
BEGIN TRANSACTION;
CREATE TEMPORARY TABLE t1_backup(a,b);
INSERT INTO t1_backup SELECT a,b FROM t1;
DROP TABLE t1;
CREATE TABLE t1(a,b);
INSERT INTO t1 SELECT a,b FROM t1_backup;
DROP TABLE t1_backup;
COMMIT;
</pre>
        </blockquote>
      </blockquote>
      <a name="q12"></a>
      <p>
        <b>(12) 我删除了大量的数据，但是数据库文件并没有变小，这是bug么？
<br />(12) I deleted a lot of data but the database file did not get any smaller. Is this a bug?</b>
      </p>
      <blockquote>
        <p>不是。当你从SQLite数据库中删除信息时，未使用的磁盘空间会被加入到一个内部的&quot;空闲列表&quot;中，并且在下次你插入数据的时候重用。磁盘空间没有丢失，只是没有返还给操作系统。
<br />No. When you delete information from an SQLite database, the unused disk space is added to an internal
        &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned
        to the operating system.</p>
        <p>如果你删除了大量数据，并且希望收缩数据库文件，那么运行<a href="lang_vacuum.html">VACUUM</a>命令。VACUUM会从磁盘碎片中重构数据库。这会将数据库的空闲列表清空，并将文件尺寸缩到最小。注意，VACUUM命令需要花费一段时间来运行（在开发SQLite的Linux机器上大约每半秒钟一兆字节）并且在运行过程中这需要使用原始文件的两倍大小的临时磁盘空间。在SQLite3.1版中，使用VACUUM命令的的使用方法之一是auto-vacuum模式，使用<a href="pragma.html#pragma_auto_vacuum">auto_vacuum pragma</a>来启用。
<br />If you delete a lot of data and want to shrink the database file, run the 
        <a href="lang_vacuum.html">VACUUM</a> command. VACUUM will reconstruct the database from scratch. This will leave the
        database with an empty free-list and a file that is minimal in size. Note, however, that the VACUUM can take some time to
        run (around a half second per megabyte on the Linux box where SQLite is developed) and it can use up to twice as much
        temporary disk space as the original file while it is running.</p>
        <p>As of SQLite version 3.1, an alternative to using the VACUUM command is auto-vacuum mode, enabled using the 
        <a href="pragma.html#pragma_auto_vacuum">auto_vacuum pragma</a>.</p>
      </blockquote>
      <a name="q13"></a>
      <p>
        <b>(13) 我能将SQLite用到我的商业软件中，而不交纳版税么？
<br />(13) Can I use SQLite in my commercial product without paying royalties?</b>
      </p>
      <blockquote>
        <p>是的。SQLite是在<a href="copyright.html">public domain</a>下。在源码的任何部分都没有声明所有权。你可以做任何你想做的事儿。
<br />Yes. SQLite is in the 
        <a href="copyright.html">public domain</a>. No claim of ownership is made to any part of the code. You can do anything you
        want with it.</p>
      </blockquote>
      <a name="q14"></a>
      <p>
        <b>(14) 如何使用一个包含了单引号(&#39;)的字符串？
<br />(14) How do I use a string literal that contains an embedded single-quote (&#39;) character?</b>
      </p>
      <blockquote>
        <p>SQL标准中指出字符串中的单引号使用一行内两个连续的单引号来转义。SQL的处理方式类似Pascal程序语言。SQLite遵循标准文档。例如：
<br />The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works
        like the Pascal programming language in the regard. SQLite follows this standard. Example:</p>
        <blockquote>
          <pre>
    INSERT INTO xyz VALUES(&#39;5 O&#39;&#39;clock&#39;);
  
</pre>
        </blockquote>
      </blockquote>
      <a name="q15"></a>
      <p>
        <b>(15) SQLITE_SCHEMA错误是什么意思，为什么会出现？
<br />(15) What is an SQLITE_SCHEMA error, and why am I getting one?</b>
      </p>
      <blockquote>
        <p>当一个预处理SQL语句不再有效并无法执行时会返回一个<a href="c3ref/c_abort.html">SQLITE_SCHEMA</a>错误。当发生这个错误时，语句必须使用<a href="c3ref/prepare.html">sqlite3_prepare()</a>API从SQL重新编译。SQLITE_SCHEMA错误只会在使用<a href="c3ref/prepare.html">sqlite3_prepare()</a>和<a href="c3ref/step.html">sqlite3_step()</a>接口运行SQL时才会发生。在<a href="c3ref/exec.html">sqlite3_exec()</a>中永远不会产生<a href="c3ref/c_abort.html">SQLITE_SCHEMA</a>错误。如果在预处理语句时使用<a href="c3ref/prepare.html">sqlite3_prepare_v2()</a>替代<a href="c3ref/prepare.html">sqlite3_prepare()</a>，那么也不会收到错误。
<br />An 
        <a href="c3ref/c_abort.html">SQLITE_SCHEMA</a> error is returned when a prepared SQL statement is no longer valid and
        cannot be executed. When this occurs, the statement must be recompiled from SQL using the 
        <a href="c3ref/prepare.html">sqlite3_prepare()</a> API. An SQLITE_SCHEMA error can only occur when using the 
        <a href="c3ref/prepare.html">sqlite3_prepare()</a>, and 
        <a href="c3ref/step.html">sqlite3_step()</a> interfaces to run SQL. You will never receive an 
        <a href="c3ref/c_abort.html">SQLITE_SCHEMA</a> error from 
        <a href="c3ref/exec.html">sqlite3_exec()</a>. Nor will you receive an error if you prepare statements using 
        <a href="c3ref/prepare.html">sqlite3_prepare_v2()</a> instead of 
        <a href="c3ref/prepare.html">sqlite3_prepare()</a>.</p>
        <p><a href="c3ref/prepare.html">sqlite3_prepare_v2()</a>接口创建的<a href="c3ref/stmt.html">预编译语句</a>会在结构发生变化时自动重新编译自身。处理<a href="c3ref/c_abort.html">SQLITE_SCHEMA</a>错误最简单的办法是永远使用<a href="c3ref/prepare.html">sqlite3_prepare_v2()</a>替换<a href="c3ref/prepare.html">sqlite3_prepare()</a>。
<br />The 
        <a href="c3ref/prepare.html">sqlite3_prepare_v2()</a> interface creates a 
        <a href="c3ref/stmt.html">prepared statement</a> that will automatically recompile itself if the schema changes. The
        easiest way to deal with 
        <a href="c3ref/c_abort.html">SQLITE_SCHEMA</a> errors is to always use 
        <a href="c3ref/prepare.html">sqlite3_prepare_v2()</a> instead of 
        <a href="c3ref/prepare.html">sqlite3_prepare()</a>.</p>
      </blockquote>
      <a name="q16"></a>
      <p>
        <b>(16) 为什么ROUND(9.95,1) 会返回9.9而不是10.0呢？9.95难道不应该向上取整么？
<br />(16) Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn&#39;t 9.95 round up?</b>
      </p>
      <blockquote>
        <p>SQLite使用二进制算法，并且在二进制中，无法使用有限位的数字来表示9.95。在64位IEEE浮点数（SQLite中使用的）中能得到的最接近的值是9.949999999999999289457264239899814128875732421875。所以当你输入 &quot;9.95&quot;时SQLite实际认为是上面那个非常长的数字。并且这个值会向下取整。
<br />SQLite uses binary arithmetic and in binary, there is no way to write 9.95 in a finite number of bits. The closest to
        you can get to 9.95 in a 64-bit IEEE float (which is what SQLite uses) is
        9.949999999999999289457264239899814128875732421875. So when you type &quot;9.95&quot;, SQLite really understands the number
        to be the much longer value shown above. And that value rounds down.</p>
        <p>这类问题在处理二进制浮点数时总是会发生。需要记住的通常规则是，大多数的小数数值在十进制（a.k.a &quot;base-10&quot;）下能用有限长度表示，但是在二进制（a.k.a &quot;base-2&quot;）下无法使用有限长度来表示。所以使用最接近的可用二进制来表示。这个近似值通常非常接近。但是有一些轻微的区别，在一些示例中结果和你所期望的会有出入。
<br />This kind of problem comes up all the time when dealing with floating point binary numbers. The general rule to remember
        is that most fractional numbers that have a finite representation in decimal (a.k.a &quot;base-10&quot;) do not have a
        finite representation in binary (a.k.a &quot;base-2&quot;). And so they are approximated using the closest binary number
        available. That approximation is usually very close, but it will be slightly off and in some cases can cause your results
        to be a little different from what you might expect.</p>
      </blockquote>
      <a name="q17"></a>
      <p>
        <b>(17) 当我编译SQLite的时候出现了上百个警告，这是因为有问题么？还是表明代码质量较差？
<br />(17) I get hundreds of compiler warnings when I compile SQLite. Isn&#39;t this a problem? Doesn&#39;t it indicate poor
        code quality?</b>
      </p>
      <blockquote>
        <p>SQLite的质量保证是通过<a href="testing.html#coverage">全覆盖测试</a>来完成的，而不是编译警告或者静态代码分析工具。换句话说，我们是验证SQLite实际工作是否能得到正确结果，而不是仅仅是满足格式上的约束。大多数SQLite基础代码都纯粹致力于测试。在每个最终版发布之前，SQLite的测试套件运行数以万计独立的测试用例，而且其中的许多测试用例是参数化的，所以上亿的测试用例调用数十亿条SQL语句运行，然后验证结果的正确性。开发者们使用代码覆盖工具来验证代码中所有的分支都被测试过。一旦在SQLite中发现一个bug，就会为这个bug添加一个新的测试用例用于展示这个bug。所以在未来不会有重复的bug未被发现。
<br />Quality assurance in SQLite is done using 
        <a href="testing.html#coverage">full-coverage testing</a>, not by compiler warnings or other static code analysis tools. In
        other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints.
        Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test
        cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL
        statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify
        that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the
        bug so that the bug cannot recur undetected in the future.</p>
        <p>在测试期间，SQLite库使用专用的测试设备编译，这允许测试脚本模拟广泛多样的失败样例，以此确保SQLite能正确的恢复。内存分配器精确的跟踪，以确保不会发生内存泄露和后续内存分配失败。使用一个自定义的VFS层来模拟操作系统崩溃和断电错误，以此确保在这些事件中事务是原子的。使用一个故意注入I/O错误的机制来展示SQLite可以弹性应对这些故障（作为一个实验，可以尝试在其他SQL数据库引擎中触发这些类型的错误，然后看看发生什么！）。
<br />During testing, the SQLite library is compiled with special instrumentation that allows the test scripts to simulate a
        wide variety of failures in order to verify that SQLite recovers correctly. Memory allocation is carefully tracked and no
        memory leaks occur, even following memory allocation failures. A custom VFS layer is used to simulate operating system
        crashes and power failures in order to ensure that transactions are atomic across these events. A mechanism for
        deliberately injecting I/O errors shows that SQLite is resilient to such malfunctions. (As an experiment, try inducing
        these kinds of errors on other SQL database engines and see what happens!)</p>
        <p>我们还在Linux上使用<a href="http://valgrind.org">Valgrind</a>来运行SQLite，确保其没有发现问题。
<br />We also run SQLite using 
        <a href="http://valgrind.org">Valgrind</a> on Linux and verify that it detects no problems.</p>
        <p>一些人说我们应当消除所有的警告，因为温和的警告会掩盖未来变动中产生的真正警告。确实是这样，但回答是，开发者么注意到所有的警告都已经在SQLite开发的编译器上修复了（各种版本的GCC）。编译警告只会在开发者不是日常使用的编译器中出现（例如MSVC）。
<br />Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in
        future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the
        compilers used for SQLite development (various versions of GCC). Compiler warnings only arise from compilers that the
        developers do not use on a daily basis (Ex: MSVC).</p>
      </blockquote>
      <a name="q18"></a>
      <p>
        <b>(18) 无法不区分大小写匹配Unicode字符。
<br />(18) Case-insensitive matching of Unicode characters does not work.</b>
      </p>
      <blockquote>SQLite的默认配置只支持ASCII字符的不区分大小写比较。这是因为做全部Unicode不区分大小写比较和大小写转换所需的表格和逻辑会使SQLite库的大小几乎增大一倍。SQLite开发者们推测任何一个需哟啊进行完整Unicode大小写支持的应用可能已经拥有必须的函数和表格，所以SQLite不再占用空间复制这个功能。
<br />The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason
      for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would
      nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case
      support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this
      ability.
      <p>取代默认提供完整Unicode大小写支持，SQLite提供了连接外部Unicode比较和转换程序的能力。应用程序可以重载内置的<a href="datatype3.html#collation">NOCASE</a>排序器（使用<a href="c3ref/create_collation.html">sqlite3_create_collation()</a>）和内置的<a href="lang_corefunc.html#like">like()</a>、<a href="lang_corefunc.html#upper">upper()</a>和<a href="lang_corefunc.html#lower">lower()</a>函数（使用<a href="c3ref/create_function.html">sqlite3_create_function()</a>。SQLite源码中包含了一个&quot;ICU&quot;扩展用于做这些重载。或者，开发者可以依照自己项目中已有的Unicode比较程序的编写自己的重载。
<br />Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode
      comparison and conversion routines. The application can overload the built-in 
      <a href="datatype3.html#collation">NOCASE</a> collating sequence (using 
      <a href="c3ref/create_collation.html">sqlite3_create_collation()</a>) and the built-in 
      <a href="lang_corefunc.html#like">like()</a>, 
      <a href="lang_corefunc.html#upper">upper()</a>, and 
      <a href="lang_corefunc.html#lower">lower()</a> functions (using 
      <a href="c3ref/create_function.html">sqlite3_create_function()</a>). The SQLite source code includes an &quot;ICU&quot;
      extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison
      routines already contained within their project.</p></blockquote>
      <a name="q19"></a>
      <p>
        <b>(19) INSERT操作非常慢——一秒钟只能执行十几条INSERT。
<br />(19) INSERT is really slow - I can only do few dozen INSERTs per second</b>
      </p>
      <blockquote>事实上，SQLite可以很容易在通常的桌面电脑上做到每秒执行50000或更多条<a href="lang_insert.html">INSERT</a>语句。但是每秒只能执行数十个事务。事务的速度受限于你的磁盘驱动器旋转速度。一次事务通常需要两次完整的磁盘旋转。这在一个7200RPM磁盘驱动器上限制了每秒大约60个事务。
<br />Actually, SQLite will easily do 50,000 or more 
      <a href="lang_insert.html">INSERT</a> statements per second on an average desktop computer. But it will only do a few dozen
      transactions per second. Transaction speed is limited by the rotational speed of your disk drive. A transaction normally
      requires two complete rotations of the disk platter, which on a 7200RPM disk drive limits you to about 60 transactions per
      second.
      <p>事务速度受限于磁盘驱动器速度，这是因为（默认）SQLite实际上会在事务完成前等待数据真正安全的存储到磁盘上。这样，如果遇到突然断电或者操作系统崩溃，你的数据依然是安全的。详细内容，参见<a href="atomiccommit.html">SQLite中的自动提交</a>。
<br />Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is
      safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS
      crashes, your data is still safe. For details, read about 
      <a href="atomiccommit.html">atomic commit in SQLite.</a>.</p>
      <p>默认情况下，每个INSERT语句都包含一个自己的事务，但是如果你使用<a href="lang_transaction.html">BEGIN</a>...<a href="lang_transaction.html">COMMIT</a>包围多条INSERT语句，那么所有的插入被划分为在了一个事务中。这时提交事务的时间被分摊到所有包含的插入语句中。所以每条插入语句耗费的时间就会大大减少。
<br />By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with 
      <a href="lang_transaction.html">BEGIN</a>... 
      <a href="lang_transaction.html">COMMIT</a> then all the inserts are grouped into a single transaction. The time needed to
      commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly
      reduced.</p>
      <p>另一个选项是运行<a href="pragma.html#pragma_synchronous">PRAGMA synchronous=OFF</a>。这个命令会使SQLite不等待数据写到磁盘上，这会使写入操作看起来快了很多，但是如果在事务过程中遇到断电，你的数据库文件可能会损坏。
<br />Another option is to run 
      <a href="pragma.html#pragma_synchronous">PRAGMA synchronous=OFF</a>. This command will cause SQLite to not wait on data to
      reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a
      transaction, your database file might go corrupt.</p></blockquote>
      <a name="q20"></a>
      <p>
        <b>(20) 我意外从SQLite数据库删除了一些重要信息，我该如何恢复呢？
<br />(20) I accidentally deleted some important information from my SQLite database. How can I recover it?</b>
      </p>
      <blockquote>如果你有一个数据库文件的备份拷贝，那么从备份中恢复信息即可。
<br />If you have a backup copy of your database file, recover the information from your backup.
      <p>如果你没有备份，那么恢复就非常困难了。你可以从原始数据库文件的二进制数据中找到部分字符串数据。通过专用工具来恢复数值数据也同样是可能的，虽然目前还不知道有这种工具存在。SQLite有时是使用<a href="compile.html#secure_delete">SQLITE_SECURE_DELETE</a>选项编译的，这样会将所有删除的内容覆盖上零。如果这样，那么恢复明显是不可能的了。如果在删除数据之后运行了<a href="lang_vacuum.html">VACUUM</a>，那么同样也是不可能恢复的了。如果没有使用SQLITE_SECURE_DELETE并且没有执行VACUUM，那么因为区域标记重用的原因，一些删除的数据可能还在数据库文件中。不过，再一次强调，就我们所知，目前还没有已有的工具或程序能帮助你恢复数据。
<br />If you do not have a backup, recovery is very difficult. You might be able to find partial string data in a binary dump of
      the raw database file. Recovering numeric data might also be possible given special tools, though to our knowledge no such
      tools exist. SQLite is sometimes compiled with the 
      <a href="compile.html#secure_delete">SQLITE_SECURE_DELETE</a> option which overwrites all deleted content with zeros. If that
      is the case then recovery is clearly impossible. Recovery is also impossible if you have run 
      <a href="lang_vacuum.html">VACUUM</a> since the data was deleted. If SQLITE_SECURE_DELETE is not used and VACUUM has not been
      run, then some of the deleted content might still be in the database file, in areas marked for reuse. But, again, there exist
      no procedures or tools that we know of to help you recover that data.</p></blockquote>
      <a name="q21"></a>
      <p>
        <b>(21) SQLITE_CORRUPT错误是什么意思？是说数据库异常么？为什么会出现这个错误？
<br />(21) What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting
        this error?</b>
      </p>
      <blockquote>
        <p>当SQLite在数据库文件中的结构、格式或者其他控制元素中发现错误时会返回一个<a href="c3ref/c_abort.html">SQLITE_CORRUPT</a>错误。
<br />An 
        <a href="c3ref/c_abort.html">SQLITE_CORRUPT</a> error is returned when SQLite detects an error in the structure, format, or
        other control elements of the database file.</p>
        <p>除非遇到非常罕见的bug（参见<a href="http://www.sqlite.org/cvstrac/wiki?p=DatabaseCorruption">数据库损坏</a>），否则SQLite不会损害数据库文件，而且即使这样，这个bug通常也是很难复现的。即使如果你的应用在一次更新的过程中崩溃了，你的数据库依然是安全的。即使操作系统崩溃或者断电，数据库也都是安全的。SQLite的抗损坏性是被广泛的计划和测试的，并且经过了真实世界中上百万用户多年的使用经验证明的。
<br />SQLite does not corrupt database files, except in the case of very rare bugs (see 
        <a href="http://www.sqlite.org/cvstrac/wiki?p=DatabaseCorruption">DatabaseCorruption</a>) and even then the bugs are
        normally difficult to reproduce. Even if your application crashes in the middle of an update, your database is safe. The
        database is safe even if your OS crashes or takes a power loss. The crash-resistance of SQLite has been extensively studied
        and tested and is attested by years of real-world experience by millions of users.</p>
        <p>这就是说，一些扩展程序或者OS或硬件的bug才可能导致数据库文件损坏。详细内容可以在SQLite支持的<a href="atomiccommit.html">自动提交</a>和<a href="lockingv3.html">锁</a>的讨论中和邮件归档中找到。
<br />That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a
        database file. Details can be found in the discussions on the 
        <a href="atomiccommit.html">atomic commit</a> and 
        <a href="lockingv3.html">locking</a> support in SQLite as well as in the mailing list archives.</p>
        <p>你可以使用<a href="pragma.html#pragma_integrity_check">PRAGMA integrity_check</a>来对数据库完整性做耗时但是彻底的检查。
<br />Your can use 
        <a href="pragma.html#pragma_integrity_check">PRAGMA integrity_check</a> to do a thorough but time intensive test of the
        database integrity.</p>
        <p>你可以使用<a href="pragma.html#pragma_quick_check">PRAGMA quick_check</a>来对数据库完整性做快速但是不完整的检查。
<br />Your can use 
        <a href="pragma.html#pragma_quick_check">PRAGMA quick_check</a> to do a faster but less thorough test of the database
        integrity.</p>
        <p>根据你的数据库损坏的程度，你可能可以通过使用CLI将结构和内容导出到一个文件中，然后重建数据库以恢复一些数据库。不幸的是，一旦积重难返，四分五裂，那么通常很难将其恢复到一起。
<br />Depending how badly your database is corrupted, you may be able to recover some of the data by using the CLI to dump the
        schema and contents to a file and then recreate. Unfortunately, once humpty-dumpty falls off the wall, it is generally not
        possible to put him back together again.</p>
      </blockquote>
      <a name="q22"></a>
      <p>
        <b>(22) SQLite支持外键么？
<br />(22) Does SQLite support foreign keys?</b>
      </p>
      <blockquote>
        <p>自3.6.19版起，SQLite支持<a href="foreignkeys.html">外键约束</a>。
<br />As of version 3.6.19, SQLite supports 
        <a href="foreignkeys.html">foreign key constraints</a>.</p>
        <p>之前版本的SQLite会解析外键约束，但是不会执行约束。等价的功能可以使用<a href="lang_createtrigger.html">SQL 触发器</a>来实现。3.6.12版之后的SQLite命令行工具提供了&quot;.genfkey&quot;命令，用于自动生成这种触发器。关于genfkey功能的更多信息参见<a href="http://www.sqlite.org/cvstrac/fileview?f=sqlite/tool/genfkey.README">自述文件</a>。
<br />Prior versions of SQLite parsed foreign key constraints, but did not enforce them. The equivalent functionality could be
        implemented using 
        <a href="lang_createtrigger.html">SQL triggers</a>. Versions 3.6.12 and later of the SQLite shell tool provided the
        &quot;.genfkey&quot; command to generate such triggers automatically. The 
        <a href="http://www.sqlite.org/cvstrac/fileview?f=sqlite/tool/genfkey.README">readme</a> for the genfkey utility contains
        more information.</p>
      </blockquote>
      <a name="q23"></a>
      <p>
        <b>(23) 当我使用SQLITE_OMIT_...编译期选项编译SQLite时出现了编译错误。
<br />(23) I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</b>
      </p>
      <blockquote><a href="compile.html#omitfeatures">SQLITE_OMIT_...</a>编译选项只能在编译标准源码文件时使用。这<u>不能</u>在<a href="amalgamation.html">联合</a>SQLite或预处理的源文件中使用。
<br />The 
      <a href="compile.html#omitfeatures">SQLITE_OMIT_...</a> compile-time options only work when building from canonical source
      files. They do 
      <u>not</u> work when you build from the SQLite 
      <a href="amalgamation.html">amalgamation</a> or from the pre-processed source files.
      <p>可以构建一个特殊的联合版，以便使用预先设定好的SQLITE_OMIT_...选项集。
      <a href="compile.html#omitfeatures">SQLITE_OMIT_... 文档</a>中有如何做的详细说明。
<br />It is possible to build a special 
      <a href="amalgamation.html">amalgamation</a> that will work with a predetermined set of SQLITE_OMIT_... options. Instructions
      for doing so can be found with the 
      <a href="compile.html#omitfeatures">SQLITE_OMIT_... documentation</a>.</p></blockquote>
      <a name="q24"></a>
      <p>
        <b>(24) WHERE 子句表达式 
          <tt>column1=&quot;column1&quot;</tt> 无法正确执行。
          会导致表中的所有行全都返回，而不是只有column1值为&quot;column1&quot;的行。
<br />(24) My WHERE clause expression 
        <tt>column1=&quot;column1&quot;</tt> does not work. It causes every row of the table to be returned, not just the rows
        where column1 has the value &quot;column1&quot;.</b>
      </p>
      <blockquote>在SQL中包围字符串的是单引号而不是双引号。这是SQL标准中要求的。你的WHERE子句表达式应当是：<tt>column1=&#39;column1&#39;</tt>
<br />Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your
      WHERE clause expression should read: 
      <tt>column1=&#39;column1&#39;</tt>
      <p>SQL里当标识符（列和表名）中含有特殊字符或者是关键词时使用双引号包围标识符。所以双引号是转义标志名的一种方法。因此当你输入<tt>column1=&quot;column1&quot;</tt>时，这等价于<tt>column1=column1</tt>，这个当然永远都是true了。
<br />SQL uses double-quotes around identifiers (column or table names) that contains special characters or which are keywords.
      So double-quotes are a way of escaping identifier names. Hence, when you say 
      <tt>column1=&quot;column1&quot;</tt> that is equivalent to 
      <tt>column1=column1</tt> which is obviously always true.</p></blockquote>
      <a name="q25"></a>
      <p>
        <b>(25) SQLite的语法图（又称“铁路”图）是如何生成的？
<br />(25) How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</b>
      </p>
      <blockquote>这个生成过程在<a href="http://wiki.tcl.tk/21708">http://wiki.tcl.tk/21708</a>中有说明。
<br />The process is explained at 
      <a href="http://wiki.tcl.tk/21708">http://wiki.tcl.tk/21708</a>.</blockquote>
      <a name="q26"></a>
      <p>
        <b>(26) SQL标准要求在一个UNIQUE约束的列中，当有一个或者多个值为NULL时触发UNIQUE约束，但是SQLite不是这样。这是一个bug么？
<br />(26) The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint
        are NULL, but SQLite does not do this. Isn&#39;t that a bug?</b>
      </p>
      <blockquote>可能你在SQL92中阅读了如下语句：
<br />Perhaps you are referring to the following statement from SQL92:
      <blockquote>在唯一列中，唯一约束要求表中不能存在两行相同的非NULL值。（A unique constraint is satisfied if and only if no two rows in a table have the same non-null values in the
      unique columns.）</blockquote>这句话是有歧义的，至少有以下两种解释：
<br />That statement is ambiguous, having at least two possible interpretations:
      <ol>
        <li>在唯一列中，唯一约束要求表中不能存在两行相同的并且值是非NULL的行。（A unique constraint is satisfied if and only if no two rows in a table have the same values and have non-null values in
        the unique columns.）</li>
        <li>在唯一列中，唯一约束要求表中非NULL的子集中不能存在两行相同的值。（A unique constraint is satisfied if and only if no two rows in a table have the same values in the subset of unique
        columns that are not null.）</li>
      </ol>SQLite遵循解释(1)，这与PostgreSQL、MySQL、Oracle和Firebird一样。不过Microsoft SQL Server和Informix使用的是解释(2)。不管怎样，SQLite的开发者们认为解释(1)是对这个要求更自然的理解。同时我们也希望能最大化的兼容其他SQL数据库引擎，并且大多数的数据库引擎也同样是遵循(1)的。所以SQLite也这么做了。
<br />SQLite follows interpretation (1), as does PostgreSQL, MySQL, Oracle, and Firebird. It is true that Informix and
      Microsoft SQL Server use interpretation (2), however we the SQLite developers hold that interpretation (1) is the most
      natural reading of the requirement and we also want to maximize compatibility with other SQL database engines, and most other
      database engines also go with (1), so that is what SQLite does.</blockquote>
      <a name="q27"></a>
      <p>
        <b>(27) SQLite的 Export Control Classification Number (ECCN) 是什么？
<br />(27) What is the Export Control Classification Number (ECCN) for SQLite?</b>
      </p>
      <blockquote>在仔细审查了Commerce Control List (CCL)之后，我们确认SQLite源码的核心公共域（public-domain）不是ECCN所描述的，因此，ECCN应当当做<b>EAR99</b>记录。
<br />After careful review of the Commerce Control List (CCL), we are convinced that the core public-domain SQLite
      source code is not described by any ECCN, hence the ECCN should be reported as 
      <b>EAR99</b>.
      <p>以上所述对于核心公共域SQLite是正确的。如果你通过添加新代码扩展SQLite或者将SQLite静态链接入你的应用中，那么在你的特例中可能要修改ECCN。
<br />The above is true for the core public-domain SQLite. If you extend SQLite by adding new code, or if you statically link
      SQLite with your application, that might change the ECCN in your particular case.</p></blockquote>
      <a name="q28"></a>
<p><b>(28) 无得查询无法返回我期望的列名，这是个bug么？
<br />(28) My query does not return the column name that I expect.  Is this a bug?</b></p>
<blockquote>如果结果集中的列使用了AS子句来命名，那么SQLite保证AS关键词右边的标识符当做列名。如果结果集中没有使用AS子句，那么SQLite会随意设置列名。更多信息参见<a href="c3ref/column_name.html">sqlite3_column_name()</a>文档。
<br />If the columns of your result set are named by AS clauses, then SQLite
  is guaranteed to use the identifer to the right of the AS keyword as the
  column name.  If the result set does not use an AS clause, then SQLite
  is free to name the column anything it wants.
  See the <a href="c3ref/column_name.html">sqlite3_column_name()</a> documentation for further information.</blockquote>
    </div>
  </body>
</html>
