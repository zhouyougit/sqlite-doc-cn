<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Appropriate Uses For SQLite</title>
<style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #044a64 }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.menubar {
  clear: both;
  border-radius: 8px;
  background: #044a64;
  padding: 0px;
  margin: 0px;
  cell-spacing: 0px;
}    
.toolbar {
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding: 0px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #044a64; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* Things for "fancyformat" documents start here. */
.fancy img+p {font-style:italic}
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#044a64}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: 'TODO:' }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of "fancyformat" specific rules. */

</style>
  
</head>
<body>
<div><!-- container div to satisfy validator -->

<a href="index.html">
<img class="logo" src="images/sqlite370_banner.gif" alt="SQLite Logo"
 border="0"></a>
<div><!-- IE hack to prevent disappearing logo--></div>
<div class="tagline">Small. Fast. Reliable.<br>Choose any three.</div>

<table width=100% class="menubar"><tr>
  <td width=100%>
  <div class="toolbar">
    <a href="about.html">关于</a>
    <a href="sitemap.html">网站地图</a>
    <a href="docs.html">文档</a>
    <a href="download.html">下载</a>
    <a href="copyright.html">许可</a>
    <a href="news.html">新闻</a>
    <a href="support.html">支持</a>
  </div>
<script>
  gMsg = "搜索SQLite文档..."
  function entersearch() {
    var q = document.getElementById("q");
    if( q.value == gMsg ) { q.value = "" }
    q.style.color = "black"
    q.style.fontStyle = "normal"
  }
  function leavesearch() {
    var q = document.getElementById("q");
    if( q.value == "" ) { 
      q.value = gMsg
      q.style.color = "#044a64"
      q.style.fontStyle = "italic"
    }
  }
  function hideorshow(btn,obj){
    var x = document.getElementById(obj);
    var b = document.getElementById(btn);
    if( x.style.display!='none' ){
      x.style.display = 'none';
      b.innerHTML='显示';
    }else{
      x.style.display = '';
      b.innerHTML='隐藏';
    }
    return false;
  }
</script>
<td>
    <div style="padding:0 1em 0px 0;white-space:nowrap">
    <form name=f method="GET" action="http://www.sqlite.org/search">
      <input id=q name=q type=text
       onfocus="entersearch()" onblur="leavesearch()" style="width:24ex;padding:1px 1ex; border:solid white 1px; font-size:0.9em ; font-style:italic;color:#044a64;" value="搜索SQLite文档...">
      <input type=submit value="Go" style="border:solid white 1px;background-color:#044a64;color:white;font-size:0.9em;padding:0 1ex">
    </form>
    </div>
  </table>

<div class=startsearch></div>
  


<h2>适合SQLite的用户
<br />Appropriate Uses For SQLite</h2>

<p>
SQLite与大多数的SQL数据库都不同，因为SQLite的核心设计目标是简洁易用：
<br />SQLite is different from most other SQL database engines in that its
primary design goal is to be simple:
</p>

<ul>
<li>易于管理
<br />Simple to administer</li>
<li>易于操作
<br />Simple to operate</li>
<li>易于嵌入大型程序
<br />Simple to embed in a larger program</li>
<li>易于维护和定制
<br />Simple to maintain and customize</li>
</ul>

<p>
很多人喜欢SQLite的原因都是它小巧而快速。但是这些特性不是最主要的。用户会发现SQLite非常的可靠，这是SQLite推崇简约的结果。减少复杂度就减少了出错的概率。所以，SQLite是小巧的，快速的，可靠的，不过最最重要的还是SQLite追求的简约。
<br />Many people like SQLite because it is small and fast.  But those
qualities are just happy accidents.
Users also find that SQLite is very reliable.  Reliability is
a consequence of simplicity.  With less complication, there is
less to go wrong.  So, yes, SQLite is small, fast, and reliable,
but first and foremost, SQLite strives to be simple.
</p>

<p>
一个简约的数据库引擎既能展现出强大，也能表现出无力，这主要取决于让其做什么。为了让SQLite更加的简约，SQLite牺牲了很多一些人认为很有用的特性，比如高并发，细粒度访问控制，丰富的内置函数，存储过程，很少使用的SQL语言特性，XML与Java扩展，T或者P级别的容量扩展等等。如果你需要这些特性而不在意因此而增加的复杂性，那么SQLite可能就不合适于你了。SQLite不准备成为一个企业数据库，也不是为何Oracle或者PostgreSQL竞争而设计的。
<br />Simplicity in a database engine can be either a strength or a
weakness, depending on what you are trying to do.  In order to
achieve simplicity, SQLite has had to sacrifice other characteristics
that some people find useful, such as high concurrency, fine-grained
access control, a rich set of built-in functions, stored procedures,
esoteric SQL language features, XML and/or Java extensions,
tera- or peta-byte scalability, and so forth.  If you need some of these
features and do not mind the added complexity that they
bring, then SQLite is probably not the database for you.
SQLite is not intended to be an enterprise database engine.  It is
not designed to compete with Oracle or PostgreSQL.
</p>

<p>
判断是否适合使用SQLite的级别原则就是：当易于管理，易于实现，易于维护比那些企业数据库提供的大量复杂特性重要时，SQLite就是一个好的选择。事实证明，简约优于复杂的情况要远比很多人想象的要多的多。
<br />The basic rule of thumb for when it is appropriate to use SQLite is
this:  Use SQLite in situations where simplicity of administration,
implementation, and maintenance are more important than the countless
complex features that enterprise database engines provide.
As it turns out, situations where simplicity is the better choice
are more common than many people realize.
</p>

<p>
换一种方式来看待SQLite：SQLite不是用来替代<a href="http://www.oracle.com/database/index.html">Oracle</a>的，而是用来替代<a href="http://man.he.net/man3/fopen">fopen()</a>的。
<br />Another way to look at SQLite is this:  SQLite is not designed
to replace <a href="http://www.oracle.com/database/index.html">Oracle</a>.
It is designed to replace <a href="http://man.he.net/man3/fopen">fopen()</a>.
</p>

<h2>适合SQLite的场景
<br />Situations Where SQLite Works Well</h2>

<ul>

<a name="appfileformat"></a>

<li><p><b>应用文件格式
<br />Application File Format</b></p>

<p>(更多<a href="appfileformat.html">详细内容</a>)
<br />(Further details <a href="appfileformat.html">here</a>.)</p>

<p>
将SQLite作为桌面应用的磁盘文件格式是一个非常好的选择，例如版本控制系统，金融分析工具，媒体目录与编辑套件，CAD包，记录程序信息等等。传统的文件打开操作通过调用sqlite3_open()方法来完成数据库文件的数据追加，当应用内容发生改变时自动更新数据库，这样文件/保存功能就变得多余了。而文件/另存为功能则可以使用<a href="backup.html">备份 API</a>来实现。
<br />SQLite has been used with great success as the on-disk file format
for desktop applications such as version control systems,
financial analysis tools, media cataloging and editing suites, CAD
packages, record keeping programs, and so forth.  The traditional
File/Open operation calls sqlite3_open() to attach to the database
file.  Updates happen atomically as application content is revised
so the File/Save menu option become superfluous.  The File/Save_As
menu option can be implemented using the <a href="backup.html">backup API</a>.
</p>

<p>
使用SQLite作为应用的文件格式有很多的优点，包括：
<br />There are many advantages to using SQLite as an application file format,
including:
</p>

<ol type="1">
<li> 无需编写和调试文件的生成与处理的代码。
<br />There is no file parsing and generating code to write and debug.
<li> 可以通过强大的SQL语句来访问和更新内容，这将极大的降低程序代码的复杂度。
<br />Content can be accessed and updated using powerful SQL queries,
     greatly reducing the complexity of the application code.
<li> 在后续发型的版本中扩展文件格式非常简单，例如新增个表或者字段。
<br />Extending the file format for new capabilities in later releases
     is a simple as adding new tables or new columns to existing tables.
<li> 不同的数据全都可以被封装在一个单独的文件中，否则可能要分别存储在“一大堆文件”中。
<br />Diverse content which might otherwise be stored as a "pile-of-files"
     can be encapsulated into a single disk file.
<li> 可以使用第三方工具来浏览内容。
<br />The content can be viewed using third-party tools.
<li> 文件可以轻易的跨平台，无论32位还是64位，大端还是小端架构。
<br />The application file is portable across all operating systems,
     32-bit and 64-bit and big- and little-endian architectures.
<li> 应用只需要加载所需的数据即可，而不用将整个文件读取到内存中并解析。启动时间和内存消耗都会得以减少。
<br />The application only has to load as much data as it needs, rather
     than reading the entire application file and holding a complete parse
     in memory.  Startup time and memory consumption are reduced.
<li> 轻微的改动只会覆盖文件中修改的部分，而不是整个文件，这有助于提高性能，降低SSD设备的损耗。
<br />Small edits only overwrite the parts of the file that change,
     not the entire file, thus improving performance
     and reducing wear on SSD drives.
<li> 内容可以实时的自动更新到数据库中，从而即使断电或者宕机也不会丢失内容。
<br />Content is updated continuously and atomically so 
     that there is no work lost in the event of a power failure or crash.
<li> 应用可以利用SQLite内置的<a href="fts3.html">全文搜索</a> 和 <a href="rtree.html">RTREE</a>功能。
<br />Applications can leverage the
     <a href="fts3.html">full-text search</a> and <a href="rtree.html">RTREE</a> capabilities that are built into SQLite.
<li> 性能问题通常可以利用<a href="lang_createindex.html">CREATE INDEX</a>来解决，而不必重新设计、重写、重测。
<br />Performance problems can often be resolved using <a href="lang_createindex.html">CREATE INDEX</a>
     rather than redesigning, rewriting, and retesting application code.
<li> 联合开发程序时，可能会使用不同的语言开发程序。如果使用SQLite，任何语言都可以直接访问应用文件，而无需担心兼容性问题。
<br />A federation of programs, perhaps written in different programming
     languages, can all access the same application file with no 
     compatibility concerns.
<li> 多个进程可以同时读写同一个应用文件，而不必担心影响到其他进程。
<br />Multiple processes can attach to the same application
     file and can read and write without interfering with each another.
<li> 跨会话的撤销/重做，都可以通过触发器来实现。
<br />Cross-session undo/redo can be implemented using triggers.
<li> 通常情况下，从SQLite数据库加载内容要比直接访问一个个独立文件快。更多信息参见<a href="intern-v-extern-blob.html">内部和外部的BLOB对比</a>
<br />In many common cases, loading content from an SQLite database
     is faster than loading content out of individual files.
     See <a href="intern-v-extern-blob.html">Internal Versus External BLOBs</a> for additional information.
<li> 存储在SQLite数据库中数据很可能在数十年之后还需要恢复，甚至到原始的应用都已经丢失了。数据的生命长于代码。
<br />Content stored in an SQLite database is more likely to be 
     recoverable decades in the future, long after all traces of
     the original application have been lost. Data lives longer than code.
</ol>

<p>
SQLite的数据文件支持任意的扩展名，所以应用程序如果需要的话可以自定义文件扩展名。<a href="pragma.html#pragma_application_id">application_id pragma</a>可以用来在数据库文件中设置一个 "Application ID"，这样，类似<a href="http://www.darwinsys.com/file/">file(1)</a>的工具就可以判断出该文件是一个应用专属的文件，而不是一个通用SQL数据库。
<br />SQLite allows database files to have any desired filename extension, so
an application can choose a custom filename extension for its own use, if
desired.  The <a href="pragma.html#pragma_application_id">application_id pragma</a> can be used to set an "Application ID"
integer in the database file so that tools like
<a href="http://www.darwinsys.com/file/">file(1)</a> can determine that the file
is associated with your application and is not just a generic
SQL database.</p>

<li><p><b>嵌入式设备和应用
<br />Embedded devices and applications</b></p>

<p>由于SQLite数据库的管理需求非常少，甚至完全不需要，因此SQLite非常适合无人值守的设备或服务。SQLite也非常适合在手机，PDA，机顶盒，家电上使用。还适合作为用户下载应用的嵌入式数据库。
<br />Because an SQLite database requires little or no administration,
SQLite is a good choice for devices or services that must work
unattended and without human support.  SQLite is a good fit for
use in cellphones, PDAs, set-top boxes, and/or appliances.  It also
works well as an embedded database in downloadable consumer applications.
</p>
</li>

<li><p><b>网站
<br />Websites</b></p>

<p>SQLite适合做中小型网站（可以说是99.9%的网站）的数据库引擎。当然，SQLite可以处理多少的网页请求依赖于网站使用数据库的压力。通常来说，每天少于10万次点击的网站都可以放心的使用SQLite。每天10万次只是一个保守的估计，而不是准确的上限。SQLite的示例可以在10倍的流量下正常工作。
<br />SQLite usually will work great as the database engine for low to
medium traffic websites (which is to say, 99.9% of all websites).
The amount of web traffic that SQLite can handle depends, of course,
on how heavily the website uses its database.  Generally
speaking, any site that gets fewer than 100K hits/day should work
fine with SQLite.
The 100K hits/day figure is a conservative estimate, not a
hard upper bound.
SQLite has been demonstrated to work with 10 times that amount
of traffic.</p>
</li>

<li><p><b>替换<i>临时</i>磁盘文件
<br />Replacement for <i>ad hoc</i> disk files</b></p>

<p>许多程序使用<a href="http://man.he.net/man3/fopen">fopen()</a>、
<a href="http://man.he.net/man3/fread">fread()</a> 和 
<a href="http://man.he.net/man3/fwrite">fwrite()</a>来创建和管理自有格式的数据文件。SQLite可以很好的替代这些临时数据文件。
<br />Many programs use 
<a href="http://man.he.net/man3/fopen">fopen()</a>,
<a href="http://man.he.net/man3/fread">fread()</a>, and 
<a href="http://man.he.net/man3/fwrite">fwrite()</a> to create and
manage files of data in home-grown formats.  SQLite works 
particularly well as a
replacement for these <i>ad hoc</i> data files.</p>
</li>

<li><p><b>内部数据库或临时数据库
<br />Internal or temporary databases</b></p>

<p>
如果程序需要对大量数据做筛选和排序操作，通常可以简单的将数据加载到SQLite的内存数据库中，然后使用查询语句、join和ORDIER BY子句来提取和排序数据，而不是尝试人工实现同样操作的代码。在程序内部这样使用SQL数据库可以给程序带来巨大的灵活性，例如增加一个新列或者索引不需要修改一行查询。
<br />For programs that have a lot of data that must be sifted and sorted
in diverse ways, it is often easier and quicker to load the data into
an in-memory SQLite database and use queries with joins and ORDER BY
clauses to extract the data in the form and order needed rather than
to try to code the same operations manually.
Using an SQL database internally in this way also gives the program
greater flexibility since new columns and indices can be added without
having to recode every query.
</p>
</li>

<li><p><b>命令行数据集分析工具
<br />Command-line dataset analysis tool</b></p>

<p>
熟练的SQL用户会使用<b>sqlite3</b>命令行工具来分析各种数据集。CSV文件中的原始数据可以导入数据库中，然后对数据进行细分来生产各种各样的概要报表。可以应用到网站日志分析，动态统计分析，处理程序指标，以及分析实验数据。
<br />Experienced SQL users can equivmploy
the command-line <b>sqlite3</b> program to analyze miscellaneous
datasets. Raw data can be imported from CSV files, then that
data can be sliced and diced to generate a myriad of summary
reports.  Possible uses include website log analysis, sports
statistics analysis, compilation of programming metrics, and
analysis of experimental results.
</p>

<p>
当然在企业数据库中也可以做同样的事儿。这种情况下，SQLite的优势在于其非常易于配置，并且只产生一个数据库文件，因此你可以存储到软盘或者闪存盘中，或者通过邮件发给同事。
<br />You can also do the same thing with an enterprise client/server
database, of course.  The advantages to using SQLite in this situation
are that SQLite is much easier to set up and the resulting database 
is a single file that you can store on a floppy disk or flash-memory stick
or email to a colleague.
</p>
</li>

<li><p><b>在做演示或者测试时替代企业数据库
<br />Stand-in for an enterprise database during demos or testing</b></p>

<p>
如果你在为一个企业数据库编写客户端应用，使用一个可以连接不同类型SQL数据库的通用数据库客户端是非常有必要的。可以在开始开发时将SQLite连入客户端程序中，通过这种方法，客户端程序就可以和SQLite一起独立运行了来完成测试或者演示。
<br />If you are writing a client application for an enterprise database engine,
it makes sense to use a generic database backend that allows you to connect
to many different kinds of SQL database engines.  It makes even better sense to go ahead and include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client.  That way the client program
can be used standalone with an SQLite data file for testing or for
demonstrations.
</p>
</li>

<li><p><b>数据库教学
<br />Database Pedagogy</b></p>

<p>
由于SQLite非常容易安装和使用（安装几乎可以忽略：只需要将<b>sqlite3</b> 或者 <b>sqlite3.exe</b>可执行文件复制到目标机器上并运行即可），所以它非常适合于SQL教学。学生可以简单的创建多个数据库并可以通过将数据库发送给导师评分。对于想学习RDBMS的实现的学生来说SQLite可以充当一个非常好的起点，因为SQLite代码是模块化的并且有优良的注释和文档。这并不是说SQLite是其它数据库实现的精确模型，但是但是如果一个学生已经理解了SQLite是如何工作的，那么就可以轻易的理解其它系统是的运行原理了。
<br />Because it is simple to setup and use (installation is trivial: just
copy the <b>sqlite3</b> or <b>sqlite3.exe</b> executable to the target machine
and run it) SQLite makes a good database engine for use in teaching SQL.
Students can easily create as many databases as they like and can
email databases to the instructor for comments or grading.  For more
advanced students who are interested in studying how an RDBMS is
implemented, the modular and well-commented and documented SQLite code
can serve as a good basis.  This is not to say that SQLite is an accurate
model of how other database engines are implemented, but rather a student who
understands how SQLite works can more quickly comprehend the operational
principles of other systems.
</p>
</li>

<li><p><b>SQL语言扩展试验
<br />Experimental SQL language extensions</b></p>

<p>SQLite简洁和模块化的设计使其成为了新原型设计和数据库语言特性与创意的理想测试平台。
<br />The simple, modular design of SQLite makes it a good platform for
prototyping new, experimental database language features or ideas.
</p>
</li>


</ul>

<h2>适合使用其它RDBMS的场景
<br />Situations Where Another RDBMS May Work Better</h2>

<ul>
<li><p><b>客户端/服务端 应用
<br />Client/Server Applications</b><p>

<p>当你有很多客户端程序都需要通过网络访问同一个数据库时你就需要考虑使用 客户端/服务端型的数据库来替换SQLite了。虽然SQLite可以运行在一个网络文件系统上，但是由于和大多数网络文件系统都有潜在的联系，所以性能往往不会很好。并且许多网络文件系统实现的文件锁逻辑都存在bug（包括Unix和Windows）。如果文件锁出现问题，那么就可能出现两个以上的客户端程序同时修改同一个数据库上的同一份数据，结果就是导致数据库被破坏。由于这些问题都是源于文件系统的实现，所以SQLite无法提供任何的保证。
<br />If you have many client programs accessing a common database
over a network, you should consider using a client/server database
engine instead of SQLite.  SQLite will work over a network filesystem,
but because of the latency associated with most network filesystems,
performance will not be great.  Also, the file locking logic of
many network filesystems implementation contains bugs (on both Unix
and Windows).  If file locking does not work like it should,
it might be possible for two or more client programs to modify the
same part of the same database at the same time, resulting in 
database corruption.  Because this problem results from bugs in
the underlying filesystem implementation, there is nothing SQLite
can do to prevent it.</p>

<p>一个原则就是，避免多个计算机通过网络文件系统使用SQLite。
<br />A good rule of thumb is that you should avoid using SQLite
in situations where the same database will be accessed simultaneously
from many computers over a network filesystem.</p>
</li>

<li><p><b>大容量网站
<br />High-volume Websites</b></p>

<p>SQLite通常可以很好的支撑起一个网站。但是如果你的网站业务繁忙，以至于你需要将数据库拆分到不同的机器上时，你就需要考虑使用一个企业级的客户端/服务的数据库引擎来替换SQLite了。
<br />SQLite will normally work fine as the database backend to a website.
But if you website is so busy that you are thinking of splitting the
database component off onto a separate machine, then you should 
definitely consider using an enterprise-class client/server database
engine instead of SQLite.</p>
</li>

<li><p><b>巨大的数据集
<br />Very large datasets</b></p>

<p>SQLite数据库的大小被限制在140TB(2<sup><small>47</small></sup> 字节, 128 TB)以下。即使能够处理这么大的数据库，大多数文件系统也会将单个数据文件的大小限制在这以下。所以，当你的数据库达到这个数量级是就需要注意了，需要考虑使用一个客户端/服务的数据库引擎将数据分散到多个磁盘文件中，甚至分散到不同的磁盘中。
<br />An SQLite database is limited in size to 140 terabytes 
(2<sup><small>47</small></sup> bytes, 128 tibibytes).
And even if it could handle larger databases, SQLite stores the entire
database in a single disk file and many filesystems limit the maximum
size of files to something less than this.  So if you are contemplating
databases of this magnitude, you would do well to consider using a
client/server database engine that spreads its content across multiple
disk files, and perhaps across multiple volumes.
</p>
</li>

<li><p><b>高并发
<br />High Concurrency</b></p>

<p>
SQLite没有限制同时读取的客户端数，但是同一时刻只能有一个客户端写数据。多数情况下，这都不是问题。每个应用都可以在数据库上快速的执行，最多等待十多毫秒。但是有些应用需要很高的并发，这时就需要寻找其它的解决方案了。
<br />SQLite supports an unlimited number of simultaneous readers, but it 
will only allow one writer at any instant in time.
For many situations, this is not a problem.  Each application
does its database work quickly and moves on, and no lock lasts for more
than a few dozen milliseconds.  But there are some applications that require
more concurrency, and those applications may need to seek a different
solution.
</p>
</li>

</ul>

