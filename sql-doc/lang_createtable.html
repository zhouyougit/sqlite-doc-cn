<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>SQLite Query Language: CREATE TABLE</title>
<style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #044a64 }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.menubar {
  clear: both;
  border-radius: 8px;
  background: #044a64;
  padding: 0px;
  margin: 0px;
  cell-spacing: 0px;
}    
.toolbar {
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding: 0px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #044a64; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* Things for "fancyformat" documents start here. */
.fancy img+p {font-style:italic}
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#044a64}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: 'TODO:' }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of "fancyformat" specific rules. */

</style>
  
</head>
<body>
<div><!-- container div to satisfy validator -->

<a href="index.html">
<img class="logo" src="images/sqlite370_banner.gif" alt="SQLite Logo"
 border="0"></a>
<div><!-- IE hack to prevent disappearing logo--></div>
<div class="tagline">Small. Fast. Reliable.<br>Choose any three.</div>

<table width=100% class="menubar"><tr>
  <td width=100%>
  <div class="toolbar">
    <a href="about.html">关于</a>
    <a href="sitemap.html">网站地图</a>
    <a href="docs.html">文档</a>
    <a href="download.html">下载</a>
    <a href="copyright.html">许可</a>
    <a href="news.html">新闻</a>
    <a href="support.html">支持</a>
  </div>
<script>
  gMsg = "搜索SQLite文档..."
  function entersearch() {
    var q = document.getElementById("q");
    if( q.value == gMsg ) { q.value = "" }
    q.style.color = "black"
    q.style.fontStyle = "normal"
  }
  function leavesearch() {
    var q = document.getElementById("q");
    if( q.value == "" ) { 
      q.value = gMsg
      q.style.color = "#044a64"
      q.style.fontStyle = "italic"
    }
  }
  function hideorshow(btn,obj){
    var x = document.getElementById(obj);
    var b = document.getElementById(btn);
    if( x.style.display!='none' ){
      x.style.display = 'none';
      b.innerHTML='显示';
    }else{
      x.style.display = '';
      b.innerHTML='隐藏';
    }
    return false;
  }
</script>
<td>
    <div style="padding:0 1em 0px 0;white-space:nowrap">
    <form name=f method="GET" action="http://www.sqlite.org/search">
      <input id=q name=q type=text
       onfocus="entersearch()" onblur="leavesearch()" style="width:24ex;padding:1px 1ex; border:solid white 1px; font-size:0.9em ; font-style:italic;color:#044a64;" value="搜索SQLite文档...">
      <input type=submit value="Go" style="border:solid white 1px;background-color:#044a64;color:white;font-size:0.9em;padding:0 1ex">
    </form>
    </div>
  </table>

<div class=startsearch></div>
  
<h1 align="center">SQLite里的SQL
<br />SQL As Understood By SQLite</h1><p><a href="lang.html">[上层Top]</a></p><h2>CREATE TABLE</h2><p><b><a href="syntaxdiagrams.html#create-table-stmt">create-table-stmt:</a></b>
<button id='x855' onclick='hideorshow("x855","x856")'>隐藏</button></p>
 <blockquote id='x856'>
 <img alt="syntax diagram create-table-stmt" src="images/syntax/create-table-stmt.gif" />
<p><b><a href="syntaxdiagrams.html#column-def">column-def:</a></b>
<button id='x857' onclick='hideorshow("x857","x858")'>显示</button></p>
 <blockquote id='x858' style='display:none;'>
 <img alt="syntax diagram column-def" src="images/syntax/column-def.gif" />
<p><b><a href="syntaxdiagrams.html#column-constraint">column-constraint:</a></b>
<button id='x859' onclick='hideorshow("x859","x860")'>显示</button></p>
 <blockquote id='x860' style='display:none;'>
 <img alt="syntax diagram column-constraint" src="images/syntax/column-constraint.gif" />
<p><b><a href="syntaxdiagrams.html#conflict-clause">conflict-clause:</a></b>
<button id='x861' onclick='hideorshow("x861","x862")'>显示</button></p>
 <blockquote id='x862' style='display:none;'>
 <img alt="syntax diagram conflict-clause" src="images/syntax/conflict-clause.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#expr">expr:</a></b>
<button id='x863' onclick='hideorshow("x863","x864")'>显示</button></p>
 <blockquote id='x864' style='display:none;'>
 <img alt="syntax diagram expr" src="images/syntax/expr.gif" />
<p><b><a href="syntaxdiagrams.html#raise-function">raise-function:</a></b>
<button id='x865' onclick='hideorshow("x865","x866")'>显示</button></p>
 <blockquote id='x866' style='display:none;'>
 <img alt="syntax diagram raise-function" src="images/syntax/raise-function.gif" />
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#foreign-key-clause">foreign-key-clause:</a></b>
<button id='x867' onclick='hideorshow("x867","x868")'>显示</button></p>
 <blockquote id='x868' style='display:none;'>
 <img alt="syntax diagram foreign-key-clause" src="images/syntax/foreign-key-clause.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#literal-value">literal-value:</a></b>
<button id='x869' onclick='hideorshow("x869","x870")'>显示</button></p>
 <blockquote id='x870' style='display:none;'>
 <img alt="syntax diagram literal-value" src="images/syntax/literal-value.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#signed-number">signed-number:</a></b>
<button id='x871' onclick='hideorshow("x871","x872")'>显示</button></p>
 <blockquote id='x872' style='display:none;'>
 <img alt="syntax diagram signed-number" src="images/syntax/signed-number.gif" />
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#type-name">type-name:</a></b>
<button id='x873' onclick='hideorshow("x873","x874")'>显示</button></p>
 <blockquote id='x874' style='display:none;'>
 <img alt="syntax diagram type-name" src="images/syntax/type-name.gif" />
<p><b><a href="syntaxdiagrams.html#signed-number">signed-number:</a></b>
<button id='x875' onclick='hideorshow("x875","x876")'>显示</button></p>
 <blockquote id='x876' style='display:none;'>
 <img alt="syntax diagram signed-number" src="images/syntax/signed-number.gif" />
</blockquote>
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#select-stmt">select-stmt:</a></b>
<button id='x877' onclick='hideorshow("x877","x878")'>显示</button></p>
 <blockquote id='x878' style='display:none;'>
 <img alt="syntax diagram select-stmt" src="images/syntax/select-stmt.gif" />
<p><b><a href="syntaxdiagrams.html#common-table-expression">common-table-expression:</a></b>
<button id='x879' onclick='hideorshow("x879","x880")'>显示</button></p>
 <blockquote id='x880' style='display:none;'>
 <img alt="syntax diagram common-table-expression" src="images/syntax/common-table-expression.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#compound-operator">compound-operator:</a></b>
<button id='x881' onclick='hideorshow("x881","x882")'>显示</button></p>
 <blockquote id='x882' style='display:none;'>
 <img alt="syntax diagram compound-operator" src="images/syntax/compound-operator.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#expr">expr:</a></b>
<button id='x883' onclick='hideorshow("x883","x884")'>显示</button></p>
 <blockquote id='x884' style='display:none;'>
 <img alt="syntax diagram expr" src="images/syntax/expr.gif" />
<p><b><a href="syntaxdiagrams.html#literal-value">literal-value:</a></b>
<button id='x885' onclick='hideorshow("x885","x886")'>显示</button></p>
 <blockquote id='x886' style='display:none;'>
 <img alt="syntax diagram literal-value" src="images/syntax/literal-value.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#raise-function">raise-function:</a></b>
<button id='x887' onclick='hideorshow("x887","x888")'>显示</button></p>
 <blockquote id='x888' style='display:none;'>
 <img alt="syntax diagram raise-function" src="images/syntax/raise-function.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#type-name">type-name:</a></b>
<button id='x889' onclick='hideorshow("x889","x890")'>显示</button></p>
 <blockquote id='x890' style='display:none;'>
 <img alt="syntax diagram type-name" src="images/syntax/type-name.gif" />
<p><b><a href="syntaxdiagrams.html#signed-number">signed-number:</a></b>
<button id='x891' onclick='hideorshow("x891","x892")'>显示</button></p>
 <blockquote id='x892' style='display:none;'>
 <img alt="syntax diagram signed-number" src="images/syntax/signed-number.gif" />
</blockquote>
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#join-clause">join-clause:</a></b>
<button id='x893' onclick='hideorshow("x893","x894")'>显示</button></p>
 <blockquote id='x894' style='display:none;'>
 <img alt="syntax diagram join-clause" src="images/syntax/join-clause.gif" />
<p><b><a href="syntaxdiagrams.html#join-constraint">join-constraint:</a></b>
<button id='x895' onclick='hideorshow("x895","x896")'>显示</button></p>
 <blockquote id='x896' style='display:none;'>
 <img alt="syntax diagram join-constraint" src="images/syntax/join-constraint.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#join-operator">join-operator:</a></b>
<button id='x897' onclick='hideorshow("x897","x898")'>显示</button></p>
 <blockquote id='x898' style='display:none;'>
 <img alt="syntax diagram join-operator" src="images/syntax/join-operator.gif" />
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#ordering-term">ordering-term:</a></b>
<button id='x899' onclick='hideorshow("x899","x900")'>显示</button></p>
 <blockquote id='x900' style='display:none;'>
 <img alt="syntax diagram ordering-term" src="images/syntax/ordering-term.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#result-column">result-column:</a></b>
<button id='x901' onclick='hideorshow("x901","x902")'>显示</button></p>
 <blockquote id='x902' style='display:none;'>
 <img alt="syntax diagram result-column" src="images/syntax/result-column.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#table-or-subquery">table-or-subquery:</a></b>
<button id='x903' onclick='hideorshow("x903","x904")'>显示</button></p>
 <blockquote id='x904' style='display:none;'>
 <img alt="syntax diagram table-or-subquery" src="images/syntax/table-or-subquery.gif" />
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#table-constraint">table-constraint:</a></b>
<button id='x905' onclick='hideorshow("x905","x906")'>显示</button></p>
 <blockquote id='x906' style='display:none;'>
 <img alt="syntax diagram table-constraint" src="images/syntax/table-constraint.gif" />
<p><b><a href="syntaxdiagrams.html#conflict-clause">conflict-clause:</a></b>
<button id='x907' onclick='hideorshow("x907","x908")'>显示</button></p>
 <blockquote id='x908' style='display:none;'>
 <img alt="syntax diagram conflict-clause" src="images/syntax/conflict-clause.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#expr">expr:</a></b>
<button id='x909' onclick='hideorshow("x909","x910")'>显示</button></p>
 <blockquote id='x910' style='display:none;'>
 <img alt="syntax diagram expr" src="images/syntax/expr.gif" />
<p><b><a href="syntaxdiagrams.html#literal-value">literal-value:</a></b>
<button id='x911' onclick='hideorshow("x911","x912")'>显示</button></p>
 <blockquote id='x912' style='display:none;'>
 <img alt="syntax diagram literal-value" src="images/syntax/literal-value.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#raise-function">raise-function:</a></b>
<button id='x913' onclick='hideorshow("x913","x914")'>显示</button></p>
 <blockquote id='x914' style='display:none;'>
 <img alt="syntax diagram raise-function" src="images/syntax/raise-function.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#type-name">type-name:</a></b>
<button id='x915' onclick='hideorshow("x915","x916")'>显示</button></p>
 <blockquote id='x916' style='display:none;'>
 <img alt="syntax diagram type-name" src="images/syntax/type-name.gif" />
<p><b><a href="syntaxdiagrams.html#signed-number">signed-number:</a></b>
<button id='x917' onclick='hideorshow("x917","x918")'>显示</button></p>
 <blockquote id='x918' style='display:none;'>
 <img alt="syntax diagram signed-number" src="images/syntax/signed-number.gif" />
</blockquote>
</blockquote>
</blockquote>
<p><b><a href="syntaxdiagrams.html#foreign-key-clause">foreign-key-clause:</a></b>
<button id='x919' onclick='hideorshow("x919","x920")'>显示</button></p>
 <blockquote id='x920' style='display:none;'>
 <img alt="syntax diagram foreign-key-clause" src="images/syntax/foreign-key-clause.gif" />
</blockquote>
<p><b><a href="syntaxdiagrams.html#indexed-column">indexed-column:</a></b>
<button id='x921' onclick='hideorshow("x921","x922")'>显示</button></p>
 <blockquote id='x922' style='display:none;'>
 <img alt="syntax diagram indexed-column" src="images/syntax/indexed-column.gif" />
</blockquote>
</blockquote>
</blockquote>


<p>"CREATE TABLE"命令用于在SQLite数据库中建立一张新表。CREATE TABLE 命令可以为新表指定如下属性：
<br />The "CREATE TABLE" command is used to create a new table in an SQLite 
database. A CREATE TABLE command specifies the following attributes of the
new table:

<ul>
  <li><p>新表的名字。
<br />The name of the new table.

  <li><p> 在哪个数据库上建表。新表可以建在主数据库上、临时库上、或者一个附加库上。
<br />The database in which the new table is created. Tables may be 
      created in the main database, the temp database, or in any attached
      database.

  <li><p> 表中每一列的名字。
<br />The name of each column in the table.

  <li><p> 表中每一列声明的类型。
<br />The declared type of each column in the table.

  <li><p> 表中每一列的默认值或者表达式。
<br />A default value or expression for each column in the table.

  <li><p> 每一列的默认排序规则。
<br />A default collation sequence to use with each column.

  <li><p> 可以选择为表指定一个PRIMARY KEY。同时支持单列主键和复合主键（多列）。
<br />Optionally, a PRIMARY KEY for the table. Both single column and
       composite (multiple column) primary keys are supported.

  <li><p> 为每列定义一组SQL约束。SQLite支持的约束有：UNIQUE、NOT NULL、CHECK和FOREIGN KEY。
<br />A set of SQL constraints for each table. SQLite supports UNIQUE, NOT
       NULL, CHECK and FOREIGN KEY constraints.

  <li><p> 是否是<a href="withoutrowid.html">WITHOUT ROWID</a>表。
<br />Whether the table is a <a href="withoutrowid.html">WITHOUT ROWID</a> table.
</ul>

<p>每条CREATE TABLE声明都必须为新表指定一个名字。“sqlite_”开头的表名都保留为内部使用。如果尝试创建一个"sqlite_"开头的表名会出现一个错误。
<br />Every CREATE TABLE statement must specify a name for the new table.
  Table names that begin with "sqlite_" are reserved for internal use. It
  is an error to attempt to create a table with a name that starts with
  "sqlite_".

<p> 如果指定了&lt;database-name&gt;那么它只能是"main"、"temp"或者<a href="lang_attach.html">附加库</a>的名字，这种情况下新表会创建在指定的库上。如果"CREATE" 和 "TABLE"关键词之间加入 "TEMP" 或 "TEMPORARY"关键词，那么会在临时库上创建新表。除非&lt;database-name&gt; 是"temp"，否则不允许同时指定&lt;database-name&gt; 和TEMP 或 TEMPORARY关键词。如果既没有指定&lt;database-name&gt; 也没有加入TEMP关键词，那么默认会在主库上创建新表。
<br />If a &lt;database-name&gt; is specified, it must be either "main", 
  "temp", or the name of an <a href="lang_attach.html">attached database</a>. In this case
  the new table is created in the named database. If the "TEMP" or "TEMPORARY"
  keyword occurs between the "CREATE" and "TABLE" then the new table is
  created in the temp database. It is an error to specify both a 
  &lt;database-name&gt; and the TEMP or TEMPORARY keyword, unless the
  &lt;database-name&gt; is "temp". If no database name is specified and the
  TEMP keyword is not present then the table is created in the main
  database.

<p>
  通常尝试在数据库里新创建的表面和库里已有的表、索引、视图的名字相同时会引发错误。不过，如果在CREATE TABLE声明中加入"IF NOT EXISTS"子句，那么当出现重名的表和视图时CREATE TABLE命令会简单的将本声明忽略（并且不会返回错误信息）。但是如果是与索引重名，那么即使加了"IF NOT EXISTS"子句，也依然会返回一个错误。
<br />It is usually an error to attempt to create a new table in a database that
  already contains a table, index or view of the same name. However, if the
  "IF NOT EXISTS" clause is specified as part of the CREATE TABLE statement and
  a table or view of the same name already exists, the CREATE TABLE command
  simply has no effect (and no error message is returned). An error is still
  returned if the table cannot be created because of an existing index, even 
  if the "IF NOT EXISTS" clause is specified.

<p>创建一个与已有<a href="lang_createtrigger.html">触发器（trigger）</a>同名的表是不会产生错误的。
<br />It is not an error to create a table that has the same name as an 
  existing <a href="lang_createtrigger.html">trigger</a>.

<p>使用<a href="lang_droptable.html">DROP TABLE</a>声明来移除表。
<br />Tables are removed using the <a href="lang_droptable.html">DROP TABLE</a> statement.  </p>

<h3>CREATE TABLE ... AS SELECT声明
<br />CREATE TABLE ... AS SELECT Statements</h3>

<p>"CREATE TABLE ... AS SELECT"声明会基于一个SELECT语句的结果来创建一个数据库表。这张表的列数与SELECT语句返回的每行数据一样。每一列的名字都和SELECT语句结果集中对于的列的名字一致。每一列的类型根据SELECT语句返回的结果集中对应列的表达式由<a href="datatype3.html#expraff">词句亲和力（Expression Affinity）</a>来决定，如下：
<br />A "CREATE TABLE ... AS SELECT" statement creates and populates a database
table based on the results of a SELECT statement. The table has the same
number of columns as the rows returned by the SELECT statement. The name of
each column is the same as the name of the corresponding column in the result
set of the SELECT statement. The declared type of each column is determined
by the <a href="datatype3.html#expraff">expression affinity</a> of the corresponding expression in the result set
of the SELECT statement, as follows:
</p>

<center><table border=1>
  <tr><th>词句亲和力（Expression Affinity ）  <th>列声明类型
  <tr><td>TEXT                  <td>"TEXT"
  <tr><td>NUMERIC               <td>"NUM"
  <tr><td>INTEGER               <td>"INT"
  <tr><td>REAL                  <td>"REAL"
  <tr><td>NONE                  <td>"" (空字符串)
</table></center>

<p>使用CREATE TABLE AS创建的表没有主键，也没有任何类型的约束。每一列的默认值是NULL，每列默认的排序器都是BINARY。
<br />A table created using CREATE TABLE AS has no PRIMARY KEY and no
constraints of any kind. The default value of each column is NULL. The default
collation sequence for each column of the new table is BINARY.

<p>使用CREATE TABLE AS 创建的表的初始内容来自于SELECT语句返回的每行数据。每行分配的<a href="lang_createtable.html#rowid">rowid</a>值按照SELECT语句返回的<a href="lang_select.html#orderby">顺序</a>，从1开始连续增长。
<br />Tables created using CREATE TABLE AS are initially populated with the
rows of data returned by the SELECT statement. Rows are assigned contiguously
ascending <a href="lang_createtable.html#rowid">rowid</a> values, starting with 1, in the <a href="lang_select.html#orderby">order</a> that they    
are returned by the SELECT statement.

<a name="tablecoldef"></a>

<h3>列定义
<br />Column Definitions</h3>

<p>除非是使用CREATE TABLE ... AS SELECT语句，否则每条CREATE TABLE语句都会包含至少一个<a href="syntaxdiagrams.html#column-def">列定义</a>，并且可以在后面跟随<a href="syntaxdiagrams.html#table-constraint">表约束</a>列表。每一个列定义由列名字、可选的列类型定义、一个或多个可选的<a href="syntaxdiagrams.html#column-constraint">列约束（column constraints）</a>组成。在列约束（column constraints）中，COLLATE和DEFAULT子句并不是真正意义上的约束，并不会对表中可能包含的数据做限制。其他的约束——NOT NULL、CHECK、UNIQUE、PRIMARY KEY 和 FOREIGN KEY约束会为表中的数据加入前置约束，在下面的<a href="lang_createtable.html#constraints">SQL 数据约束</a>中又详细描述。
<br />Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes
one or more <a href="syntaxdiagrams.html#column-def">column definitions</a>, optionally followed by a list of
<a href="syntaxdiagrams.html#table-constraint">table constraints</a>.  Each column definition consists of the
name of the column, optionally followed by the declared type of the column,
then one or more optional <a href="syntaxdiagrams.html#column-constraint">column constraints</a>. Included in
the definition of "column constraints" for the purposes of the previous
statement are the COLLATE and DEFAULT clauses, even though these are not really
constraints in the sense that they do not restrict the data that the table may
contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and
FOREIGN KEY constraints - impose restrictions on the tables data, and are are
described under <a href="lang_createtable.html#constraints">SQL Data Constraints</a> below.

<p>与大多数的SQL数据库不同，SQLite不会依照列的声明类型来限制插入数据的类型。相反，SQLite使用的是<a href="datatype3.html">动态类型</a>。列的声明类型仅仅是用于决定列的<a href="datatype3.html#affinity">亲和力</a>
<br />Unlike most SQL databases, SQLite does not restrict the type of data that
may be inserted into a column based on the columns declared type. Instead,
SQLite uses <a href="datatype3.html">dynamic typing</a>. The declared type of a column is used to
determine the <a href="datatype3.html#affinity">affinity</a> of the column only.

<p>当用户做<a href="lang_insert.html">INSERT</a>操作时没有为一列提供明确的值时，会使用DEFAULT子句指定的默认值。
<br />如果在列定义上没有显示的添加DEFAULT子句，那么列的默认值则是NULL。DEFAULT子句可以指定的的默认值包含NULL、字符串常量、BLOB常量、有符号数或者包含在圆括号中的常量表达式。默认值还可以是下面这些大小写无关的关键字之一——CURRENT_TIME、CURRENT_DATE、CURRENT_TIMESTAMP。在DEFAULT子句中，表达式应该是一个经过深思熟虑的常量，不能包含子查询、列或表引用、包含在双引号中的字符串。
<br />The DEFAULT clause specifies a default value to use for the column if no
value is explicitly provided by the user when doing an <a href="lang_insert.html">INSERT</a>. If there
is no explicit DEFAULT clause attached to a column definition, then the 
default value of the column is NULL. An explicit DEFAULT clause may specify
that the default value is NULL, a string constant, a blob constant, a
signed-number, or any constant expression enclosed in parentheses. An explicit
default value may also be one of the special case-independent keywords
CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the
DEFAULT clause, an expression is considered constant provided that it does
not contain any sub-queries, column or table references, or string literals
enclosed in double-quotes instead of single-quotes.

<p>每当通过INSERT语句向表中插入一行记录时，对于所有没有明确提供值的表列，在新行中存储的数值是由默认值决定的。如下：
<br />Each time a row is inserted into the table by an INSERT statement that 
does not provide explicit values for all table columns the values stored in
the new row are determined by their default values, as follows:

<ul>
  <li><p>如果列的默认值包含NULL、文本、BLOB或者有符号数，那么这个值会直接插入到新行中。
<br />If the default value of the column is a constant NULL, text, blob or
    signed-number value, then that value is used directly in the new row.

  <li><p>如果默认值是一个包含在圆括号中的表达式，那么表达式会在每次插入式计算一次，并把计算结果插入到新行中。
<br />If the default value of a column is an expression in parentheses, then
    the expression is evaluated once for each row inserted and the results
    used in the new row.

  <li><p>如果列的默认值是CURRENT_TIME、 CURRENT_DATE 或者 CURRENT_TIMESTAMP，那么会讲当前的UTC时间与日期的字符串表示插入到新行中。CURRENT_TIME的格式是"HH:MM:SS"，CURRENT_DATE的格式是 "YYYY-MM-DD"，CURRENT_TIMESTAMP 的格式是 "YYYY-MM-DD HH:MM:SS"。
<br />If the default value of a column is CURRENT_TIME, CURRENT_DATE or
    CURRENT_TIMESTAMP, then the value used in the new row is a text
    representation of the current UTC date and/or time. For CURRENT_TIME, the
    format of the value is "HH:MM:SS". For CURRENT_DATE, "YYYY-MM-DD". The
    format for CURRENT_TIMESTAMP is "YYYY-MM-DD HH:MM:SS".
</ul>

<p>COLLATE子句为列指定一个默认的<a href="datatype3.html#collation">排序器</a>的名字。如果没有指定COLLATE子句，那么默认的排序器是<a href="datatype3.html#collation">BINARY</a>
<br />The COLLATE clause specifies the name of a <a href="datatype3.html#collation">collating sequence</a> to use as
the default collation sequence for the column. If no COLLATE clause is
specified, the default collation sequence is <a href="datatype3.html#collation">BINARY</a>.

<p>一张表中列的数量被限制在了编译期参数<a href="limits.html#max_column">SQLITE_MAX_COLUMN</a>之内。一个独立行存储数据的最大长度为<a href="limits.html#max_length">SQLITE_MAX_LENGTH</a>字节。这两个限制都可以在运行期使用C/C++接口<a href="c3ref/limit.html">sqlite3_limit()</a>来降低。
<br />The number of columns in a table is limited by the <a href="limits.html#max_column">SQLITE_MAX_COLUMN</a>
compile-time parameter. A single row of a table cannot store more than
<a href="limits.html#max_length">SQLITE_MAX_LENGTH</a> bytes of data. Both of these limits can be lowered at
runtime using the <a href="c3ref/limit.html">sqlite3_limit()</a> C/C++ interface.</p>

<a name="constraints"></a>

<h3>SQL数据约束
<br />SQL Data Constraints</h3>

<a name="primkeyconst"></a>

<p>SQLite中每个表最多包含一个<b>PRIMARY KEY</b>。如果在列的定义中加入关键字PRIMARY KEY，那么表的主键就由这一列构成。或者，将PRIMARY KEY作为一个<a href="syntaxdiagrams.html#table-constraint">表约束</a>指定，那么表的主键就由PRIMARY KEY子句中指定的列列表构成。如果在一个CREATE TABLE语句中出现了一个以上的PRIMARY KEY子句，那么会抛出一个错误。PRIMARY KEY对于普通表来说是可选的，但是对于<a href="withoutrowid.html">WITHOUT ROWID</a>表则是必须的。
<br />Each table in SQLite may have at most one <b>PRIMARY KEY</b>. If the
  keywords PRIMARY KEY are added to a column definition, then the primary key
  for the table consists of that single column. Or, if a PRIMARY KEY clause 
  is specified as a <a href="syntaxdiagrams.html#table-constraint">table-constraint</a>, then the primary key of the table
  consists of the list of columns specified as part of the PRIMARY KEY clause.
  An error is raised if more than one PRIMARY KEY clause appears in a
  CREATE TABLE statement.  The PRIMARY KEY is optional for ordinary tables
  but is required for <a href="withoutrowid.html">WITHOUT ROWID</a> tables.

<p>如果一个表只有一个申明类型为“INTEGER”的列是主键，并且不是一个<a href="withoutrowid.html">WITHOUT ROWID</a>表，那么这一列会被作为一个<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>。关于<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>相关的专用参数和行为，详见下文。
<br />If a table has a single column primary key and the declared type of that
  column is "INTEGER" and the table is not a <a href="withoutrowid.html">WITHOUT ROWID</a> table,
  then the column is known as an <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>.
  See below for a description of the special properties and behaviors
  associated with an <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>.

<p>每个包含了primary key的表都必须为主键列的值或联合值是全表唯一的。为了保证主键值的唯一性，NULL会被认为是有别于其他所有值的值，包括其他的NULL。视图通过<a href="lang_insert.html">INSERT</a> 或 <a href="lang_update.html">UPDATE</a>语句将表中两个以上主键的内容修改成完全一样会导致约束违规。依照SQL标准，PRIMARY KEY是应当包含NOT NULL的。不幸的是，为了兼容一些早期版本的bug，所以这条在SQLite中没有支持。除非这一列是<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a>，或者是一个<a href="withoutrowid.html">WITHOUT ROWID</a>表，或者列被定义为NOT NULL才符合SQLite标准规范，但是这么做可能会破坏遗留程序。因此，这仅仅是文档中的定义，事实上SQLite是允许大多数的PRIMARY KEY列包含NULL的。
<br />Each row in a table with a primary key must have a unique combination
  of values in its primary key columns. For the purposes of determining
  the uniqueness of primary key values, NULL values are considered distinct from
  all other values, including other NULLs. If an <a href="lang_insert.html">INSERT</a> or <a href="lang_update.html">UPDATE</a>
  statement attempts to modify the table content so that two or more rows
  feature identical primary key values, it is a constraint violation.
  According to the SQL standard, PRIMARY KEY should always imply NOT NULL.
  Unfortunately, due to a bug in some early versions, this is not the
  case in SQLite. Unless the column is an <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> or
  the table is a <a href="withoutrowid.html">WITHOUT ROWID</a> table or the column is declared NOT NULL,
  SQLite allows NULL values in a PRIMARY KEY column.  SQLite could be fixed to
  conform to the standard, but doing so might break legacy applications.
  Hence, it has been decided to merely document the fact that SQLite
  allowing NULLs in most PRIMARY KEY columns.

<a name="uniqueconst"></a>

<p><b>UNIQUE</b>约束类似于PRIMARY KEY约束，不过一个表可以包含多个UNIQUE约束。对于每一条UNIQUE约束，都要保证指定列每行的值或者联合值在表中是唯一的。在UNIQUE约束中，NULL值被认为是有别于其它所有值的值，包括其他的NULL。
<br />A <b>UNIQUE</b> constraint is similar to a PRIMARY KEY constraint, except
  that a single table may have any number of UNIQUE constraints. For each
  UNIQUE constraint on the table, each row must contain a unique combination
  of values in the columns identified by the UNIQUE constraint. 
  For the purposes of UNIQUE constraints, NULL values
  are considered distinct from all other values, including other NULLs.

<p>通常，UNIQUE和PRIMARY KEY 都是通过在数据库中创建一个唯一索引来实现的（除了<a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> 和 <a href="withoutrowid.html">WITHOUT ROWID</a>表上的PRIMARY KEY）。因此下面的表述在逻辑上是相同的。
<br />In most cases, UNIQUE and PRIMARY KEY
  constraints are implemented by creating a unique index in the database.
  (The exceptions are <a href="lang_createtable.html#rowid">INTEGER PRIMARY KEY</a> and PRIMARY KEYs on 
  <a href="withoutrowid.html">WITHOUT ROWID</a> tables.)
  Hence, the following schemas are logically equivalent:

  <ol>
  <li><p>CREATE TABLE t1(a, b UNIQUE);
  <li><p>CREATE TABLE t1(a, b PRIMARY KEY);
  <li><p>CREATE TABLE t1(a, b);<br>
         CREATE UNIQUE INDEX t1b ON t1(b);
  </ol>

<a name="ckconst"></a>

<p><b>CHECK</b>约束可以附加在列定义上也可以作为一个表约束。在实践中这是没有区别的。每当向表中插入新行或者更新已存在的表时，每个CHECK约束指定的表达式就会被计算，并以<a href="lang_expr.html#castexpr">CAST 表达式</a>同样的方式转换到一个NUMERIC值。如果结果是零（整数0或者实数0.0），那么就会发生约束违规。如果CHECK表达式计算结果为NULL或者其它非零的值，则不会发生约束违规。CHECK约束表达式不允许包含子查询。
<br />A <b>CHECK</b> constraint may be attached to a column definition or
  specified as a table constraint. In practice it makes no difference. Each
  time a new row is inserted into the table or an existing row is updated,
  the expression associated with each CHECK constraint is evaluated and
  cast to a NUMERIC value in the same way as a <a href="lang_expr.html#castexpr">CAST expression</a>. If the 
  result is zero (integer value 0 or real value 0.0), then a constraint
  violation has occurred. If the CHECK expression evaluates to NULL, or
  any other non-zero value, it is not a constraint violation.
  The expression of a CHECK constraint may not contain a subquery.

<p>CHECK约束是从<a href="releaselog/3_3_0.html">3.3.0版</a>才开始支持的。早于3.3.0的版本会解析CHECK约束，但是不会生效CHECK constraints have been supported since <a href="releaselog/3_3_0.html">version 3.3.0</a>. Prior to
  version 3.3.0, CHECK constraints were parsed but not enforced.

<a name="notnullconst"></a>

<p><b>NOT NULL</b>约束只能附加在列定义上，不能指定为表约束。显然，一个NOT NULL约束规定该列不能包含NULL值。视图在插入新行或者更新已有行时给该列设置NULL值会引发约束违规。
<br />A <b>NOT NULL</b> constraint may only be attached to a column definition,
  not specified as a table constraint.  Not surprisingly, a NOT NULL
  constraint dictates that the associated column may not contain a NULL value.
  Attempting to set the column value to NULL when inserting a new row or
  updating an existing one causes a constraint violation.

<p>当遇到冲突违规时如何处理是由<a href="lang_conflict.html">约束冲突解决算法</a>来决定的。每一个PRIMARY KEY、 UNIQUE、 NOT NULL 和 CHECK约束都可以通过在定义中包含一个<a href="syntaxdiagrams.html#conflict-clause">conflict-clause</a>来明确指定一个默认的冲突解决算法。或者，如果是一个CHECK约束，在约束定义中没有包含<a href="syntaxdiagrams.html#conflict-clause">conflict-clause</a>，那么默认的约束解决算法是ABORT。在同一个表中，不同的约束可以有不同的默认冲突解决算法。详细信息参考<a href="lang_conflict.html">ON CONFLICT</a>一节。
<br />Exactly how a constraint violation is dealt with is determined by the
  <a href="lang_conflict.html">constraint conflict resolution algorithm</a>. Each 
  PRIMARY KEY, UNIQUE, NOT NULL and CHECK constraint has a default conflict
  resolution algorithm. PRIMARY KEY, UNIQUE and NOT NULL constraints may be
  explicitly assigned a default conflict resolution algorithm by including
  a <a href="syntaxdiagrams.html#conflict-clause">conflict-clause</a> in their definitions. Or, if a constraint definition
  does not include a <a href="syntaxdiagrams.html#conflict-clause">conflict-clause</a> or it is a CHECK constraint, the default
  conflict resolution algorithm is ABORT. Different constraints within the
  same table may have different default conflict resolution algorithms. See
  the section titled <a href="lang_conflict.html">ON CONFLICT</a> for additional information.

<a name="rowid"></a>

<h3>ROWID和INTEGER PRIMARY KEY
<br />ROWIDs and the INTEGER PRIMARY KEY</h3>

<p>在SQLie中，除了<a href="withoutrowid.html">WITHOUT ROWID</a>表，其他所有的表的所有行都会有一个64位的有符号整数键，用于唯一标识表中的每一行。这个整数通常叫做“rowid”。这个整数通常可以在列名字位置，通过“rowid”、“oid”、“_rowid_”这三个不区分大小写的特殊名字来访问。如果在一个表中，用户定义了名为“rowid”、“oid”、“_rowid_”的列，那么这个名字只会引用到明确定义的列，无法用来获取整数的rowid值。
<br />Except for <a href="withoutrowid.html">WITHOUT ROWID</a> tables, all rows within SQLite tables
have a 64-bit signed integer key that uniquely identifies the row within its table.
This integer is usually
called the "rowid". The rowid value can be accessed using one of the special
case-independent names "rowid", "oid", or "_rowid_" in place of a column name.
If a table contains a user defined column named "rowid", "oid" or "_rowid_",
then that name always refers the explicitly declared column and cannot be used
to retrieve the integer rowid value.

<p>在 <a href="withoutrowid.html">WITHOUT ROWID</a>表中会忽略rowid（“oid”和“_rowid_”）。WITHOUT ROWID 表只在<a href="releaselog/3_8_2.html">3.8.2版本</a>及后续版本的SQLite中有效。不包含WITHOUT ROWID子句的表被称为“rowid table”。
<br />The rowid (and "oid" and "_rowid_") is omitted in <a href="withoutrowid.html">WITHOUT ROWID</a> tables.
WITHOUT ROWID tables are only available in SQLite <a href="releaselog/3_8_2.html">version 3.8.2</a> and later.
A table that lacks the WITHOUT ROWID clause is called a "rowid 表".

<p>rowid表中的数据是存储在一个B-Tree结构中的，每行对应一个记录，使用rowid作为键。这意味着使用rowid来获取记录或者排序会很快。使用rowid来搜索记录，或者查找一个指定范围的记录的速度会比在PRIMARY KEY或者建立了索引的其它值上做类似的事情快一倍。
<br />The data for rowid tables is stored as a B-Tree structure containing
one entry for each table row, using the rowid value as the key. This means that
retrieving or sorting records by rowid is fast. Searching for a record with a
specific rowid, or for all records with rowids within a specified range is
around twice as fast as a similar search made by specifying any other PRIMARY
KEY or indexed value.

<p> 下面有一个例外，如果一个rowid表有一个又唯一列构成的主键，并且这一列的类型声明为“INTEGER”（忽略大小写），那么这一列就是rowid的一个别名。这样的列通常称为“整数主键（integer primary key）”。一个主键列只有当声明类型名是“INTEGER”时才能变成一个整数主键。其它的整数类型名例如“INT”、“BIGINT”、“SHORT INTEGER”、 “UNSIGNED INTEGER”都会导致主键列成为一个普通的整数<a href="datatype3.html#affinity">亲和力</a>的表列和一个唯一索引，而不是rowid的别名。
<br />With one exception noted below, if a rowid table has a primary key that consists
of a single column and the declared type of that column is "INTEGER" in any mixture of
upper and lower case, then the column becomes an alias for the rowid. Such a
column is usually referred to as an "integer primary key". A PRIMARY KEY column
only becomes an integer primary key if the declared type name is exactly
"INTEGER".  Other integer type names like "INT" or "BIGINT" or "SHORT INTEGER"
or "UNSIGNED INTEGER" causes the primary key column to behave as an ordinary
table column with integer <a href="datatype3.html#affinity">affinity</a> and a unique index, not as an alias for
the rowid.

<p>还有一个例外是如果一个列声明类型为“INTEGER”并且包含一个“PRIMARY KEY DESC”子句，那么这一列不会成为rowid的别名，也不能称为整数主键。这个怪异的情况不是专门设计的，而是为了兼容SQLite早期版本的bug。如果修复这个bug会导致向后不兼容。因此，原始的行为被保留下来了（并记录在文档中），因为小的特殊行为要比破坏兼容性好的多。下面的三个表声明，全都会使“x“成为rowid的别名（一个整数主键）：
<br /> The exception mentioned above is that if the declaration of a column with
declared type "INTEGER" includes an "PRIMARY KEY DESC" clause, it does not
become an alias for the rowid and is not classified as an integer primary key.
This quirk is not by design. It is due to a bug in early versions of SQLite.
But fixing the bug could result in backwards incompatibilities.
Hence, the original behavior has been retained (and documented) because
behavior in a corner case is far better than a compatibility break.  This means
that the following three table declarations all cause the column "x" to be an
alias for the rowid (an integer primary key):

<ul>
<li><tt>CREATE TABLE t(x INTEGER PRIMARY KEY ASC, y, z);</tt>
<li><tt>CREATE TABLE t(x INTEGER, y, z, PRIMARY KEY(x ASC));</tt>
<li><tt>CREATE TABLE t(x INTEGER, y, z, PRIMARY KEY(x DESC));</tt>
</ul>

<p>但是下面的声明不会使“x”成为rowid的别名。
<br />But the following declaration does not result in "x" being an alias for
the rowid:
<ul>
<li><tt>CREATE TABLE t(x INTEGER PRIMARY KEY DESC, y, z);</tt>
</ul>

<p>rowid值可以使用UPDATE语句以类似其他列的方式修改。既可以使用内置别名（“rowid”、“oid”或“_rowid_”）也可以使用整数主键创建的别名。同样，INSERT语句也可以在插入行的时候为rowid提供一个值，与通常的SQLite列不同，整数主键或者rowid列只能包含整数。整数主键和rowid不能存储浮点数、字符串、BLOB或者NULL。
<br />Rowid values may be modified using an UPDATE statement in the same
way as any other column value can, either using one of the built-in aliases
("rowid", "oid" or "_rowid_") or by using an alias created by an integer
primary key. Similarly, an INSERT statement may provide a value to use as the
rowid for each row inserted. Unlike normal SQLite columns, an integer primary
key or rowid column must contain integer values. Integer primary key or rowid
columns are not able to hold floating point values, strings, BLOBs, or NULLs.

<p>当UPDATE语句试图将整数主键或rowid列修改为一个NULL、BLOB、字符串或者实数值，并且该值无法无损的转换为一个整数，那么就会引发一个“datatype mismatch”错误，并且语句会被忽略。当INSERT语句试图为整数主键或rowid列插入一个BLOB、字符串或者实数值，并且该值无法无损的转换为一个integer，那么就会引发一个“datatype mismatch”错误，并且语句会被忽略。
<br />If an UPDATE statement attempts to set an integer primary key or rowid column
to a NULL or blob value, or to a string or real value that cannot be losslessly
converted to an integer, a "datatype mismatch" error occurs and the statement
is aborted. If an INSERT statement attempts to insert a blob value, or a string
or real value that cannot be losslessly converted to an integer into an
integer primary key or rowid column, a "datatype mismatch" error occurs and the
statement is aborted.

<p>如果INSERT语句试图插入一个NULL值到rowid或者整数主键列中，系统会自动选择一个整数值作为rowid。详情参见<a href="autoinc.html">这里</a>。
<br />If an INSERT statement attempts to insert a NULL value into a rowid or
integer primary key column, the system chooses an integer value to use as the
rowid automatically. A detailed description of how this is done is provided
<a href="autoinc.html">separately</a>.</p>

<p><a href="foreignkeys.html">外键约束</a>的<a href="foreignkeys.html#parentchild">父键</a>不允许使用rowid。父键只能使用命名的列。
<br />The <a href="foreignkeys.html#parentchild">parent key</a> of a <a href="foreignkeys.html">foreign key constraint</a> is not allowed to
use the rowid.  The parent key must used named columns only.</p>


